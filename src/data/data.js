export const blogListProfiles = [{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"]},{"title":"观‘技术人不要看中文’有感","date":"2022-04-29","tags":["essay"]},{"title":"字节码-无关性的基石","date":"2022-05-04","tags":["Java","byte","code"]},{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"]},{"title":"reactive programming","date":"2022-05-11","tags":["reactive","编程风格"]},{"title":"123.买卖股票的最佳时机Ⅲ","date":"2022-05-03","tags":["leetcode"]},{"title":"42.接雨水","date":"2022-05-03","tags":["leetcode"]},{"title":"使用redis实现分布式锁","date":"2022-04-29","tags":["redis","分布式锁"]},{"title":"编程相关小技巧","date":"2022-04-29","tags":["技巧"]},{"title":"rabbitmq与AMQP","date":"2022-05-01","tags":["消息队列","中间件","rabbitmq"]},{"title":"rabbitmq中的消息发布与消费","date":"2022-05-02","tags":["rabbitmq"]},{"title":"rabbitmq中的队列和exchange","date":"2022-05-02","tags":["rabbitmq","中间件","消息队列"]}];
export const blogsMap = [{"title":"what is spring webflux","payload":{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}},{"title":"观‘技术人不要看中文’有感","payload":{"title":"观‘技术人不要看中文’有感","date":"2022-04-29","tags":["essay"],"categories":"随笔","content":"\r\n\r\n今日B站给推送一个视频，标题叫‘[50岁程序员：技术人不准看中文！](https://www.bilibili.com/video/BV1Sr4y1J7K9?spm_id_from=333.999.0.0)’ 。短短25秒大致意思就是中文互联网下所获取学习到的相关技术已经比其原本所具备的能力打了折扣。评论最高赞的三个评论我贴在下方。![反对方论点](../resources/img/journal_review1.png)  ![支持方论点](../resources/img/journal_review2.png)\r\n\r\n就我个人来说，技术人不准看中文大致上是准确。诚然，中文互联网上是可以找到大量优质的技术文章，它们或者短小精悍，或者详尽有趣，看完也能大有收获。但是呢，这里有一个问题，我怎么才能找到这些文章呢？对于一个小白来说代价有点大。遇到问题，借助百度，搜到的答案要么同质化程度太高，要么水平低下，要么早已过时。(google好一些，但或多或少还是会遇到这种情况，怎么解决还有待探索)。一些技术论坛，rss的情况好一些，可以时不时的找到一些高质量文章，有时在评论区也能有所收获，但也都是随缘，毕竟这些生产高质量文章的大佬一是更新日期不固定，二是实时的关注点也会有所差异。当然我们也可以去看书，这里有两类，一类是由英文翻译而来的技术书，一类是中文作者原创的技术书。中文原创的技术书一般都是实战型，就着某个框架，某门技术给你现造个应用出来，这么做其实好的，编程这个东西就得实践，看一百本书都比不上做一个完整项目的收获大。但是这么做也是有问题的，一本几百页的书并且是在以项目为基础的前提下所能包含的相关技术的内涵是有限的，而且这些书一般也会绑定某个版本做项目，当我们要换个版本做应用，并且版本的变化相对较大时，我们还是得去看官方的文档，这些文档鲜少会提供中文。至于由英文翻译而来的技术书呢，则良莠不齐，有些甚至都可以看出是机翻。\r\n\r\n所以对于反对者所说的看英文文档效率低的问题我是不认同的，相对与在中文互联网中四处闲逛还是收获甚小所造成的开销，翻译层的开销是可以忽略的。至于后半段真假参半的话术，还扯上脊梁问题，那就令人反感了。这里为什么说真假参半呢，因为这里是有指导意义的，读应当读英文，那些大佬有空也可以做一些优秀的中文输出反馈到中文社区，从而形成中文互联网的良性循环。虽然在这个流量变现，而不是付费变现的时代，期待这成为现实有些困难，但万一呢 :wink: "}},{"title":"字节码-无关性的基石","payload":{"title":"字节码-无关性的基石","date":"2022-05-04","tags":["Java","byte","code"],"categories":"Java","content":"\r\n\r\n字节码技术是虚拟机实现平台无关性，语言无关性的基石，得益于此，Java语言才能在嵌入式，web服务端等领域大展拳脚并受到长期欢迎。围绕字节码技术，发展出一批拥有不同特性的运行于Java虚拟机之上的编程语言，如groovy，Scala，kotlin等。虚拟机只与class文件绑定，它不关心class文件来自何处，是来自本地的磁盘文件，还是来自于网络，是由.java文件编译而来，还是由.groovy文件编译而来，只要是有效的class文件，虚拟机便能够运行。\r\n\r\n一个class文件由连续的8-bit、16-bit和32-bit的无符号数的流构成，并且以大端模式存储。class文件的格式可以以一种C-like结构体的方式描述，结构体由`items`和`tables`构成。tables由零个或者任意的items构成。class文件的格式结构体描述如下，其中u1，u2，u4为`items`,_info结尾的项为`tables`\r\n\r\n    ClassFile{\r\n        u4              magic;\r\n        u2              minor_version;\r\n        u2              major_version;\r\n        u2              constant_pool_count;\r\n        cp_info         constant_pool[constant_pool_count-1];\r\n        u2              access_flags;\r\n        u2              this_class;\r\n        u2              super_class;\r\n        u2              interfaces_count;\r\n        u2              interfaces[interfaces_count];\r\n        u2              fields_count;\r\n        field_info      fields[fields_count];\r\n        u2              methods_count;\r\n        method_info     methods[methods_count];\r\n        u2              attributes_count;\r\n        attribute_info  attributes[attributes_count];\r\n    }\r\n\r\n> magic\r\n\r\n魔数，固定为OxCAFEBABE,标志为一个class文件。\r\n\r\n> minor_version,major_version\r\n\r\n它们共同决定了一个class文件的版本，不同的Java SE所能支持的class文件版本是不同的，比如Java8支持主版本45-52，Java18支持主版本45-62。主版本号 >= 56时，此版本号限制为0或者65535，之前的主版本则随意。Java虚拟机的实现如果遵循JavaSE的某版本(>=12)，那么就必须支持该版本的preview feature，并且默认关闭支持，但是提供途径可以开启支持。一个class文件的版本若为(45 - N+44).65535的形式，则其是依赖JavaSEN的preview feature的class文件。一个遵循JavaSEN的虚拟机实现，只有在开启preview feature支持时，才能加载(45 - N+44).65535的class文件，普通的则不受影响。\r\n\r\n> constant_pool_count\r\n\r\n常量池条目的数量加一。\r\n\r\n> constant_pool[]\r\n\r\n常量池是一张可包含各种字符串常量，类名，接口名，字段名以及其他表示class文件中条目的常量的表，表中entry的格式由其第一个字节`tag`指示。常量表的索引从1到constant_pool_count - 1。\r\n\r\n> access_flags\r\n\r\naccess_flags是一个掩码标记，用来指示一个类或者接口的访问权限以及各种属性。\r\n\r\n|Flag name|Value|Interpretation|\r\n|:-|:-:|:-|\r\n|ACC_PUBLIC|0x0001|Declared public; may be accessed from outside its package.|\r\n|ACC_FINAL|0x0010|Declared final; no subclasses allowed|\r\n|ACC_SUPER|0x0020|Treat superclass methods specially when invoked by the invokespecial instruction|\r\n|ACC_INTERFACE|0x0200|Is an interface, not a class|\r\n|ACC_ABSTRACT|0x0400|Declared abstract; must not be instantiated|\r\n|ACC_SYNTHETIC|0x1000|Declared synthetic; not present in the source code.|\r\n|ACC_ANNATATION|0x2000|Declared as an annotation interface.|\r\n|ACC_ENUM|0x4000|Declared as an enum class.|\r\n|ACC_MODULE|0x8000|Is a module, not a class or interface.|\r\n\r\nACC_SUPER用来指示当遇到invokespecial指令将表示的两种语义时，应该选择哪种进行解释。Java8之后，无论class文件是否设置该值，虚拟机都认为设置了。ACC_SYNTHETIC指示该类或者接口是由编译器动态生成的，而不是本身就存在于源码中的。\r\n\r\n> this_class\r\n\r\n该值是常量池表的一个有效索引，索引指向的条目必须是一个代表该类或者接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> super_class\r\n\r\n该值或为0或为指向常量池的一个有效索引，若为0，则超类为Object，否则指向常量池中一个代表超类结构的`CONSTANT_Class_info`类型。\r\n\r\n> interfaces_count\r\n\r\n代表该类或者接口有几个直接父接口。\r\n\r\n> interfaces[]\r\n\r\n一个指向常量池的有效索引的数组，每个索引指向的条目必须是代表父接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> fields_count\r\n\r\n指示该类或接口的类变量和实例变量的总数目。\r\n\r\n> fields[]\r\n\r\n字段表的每个条目必须是`field_info`结构，用来表示一个字段的完整描述。\r\n\r\n> methods_count\r\n\r\n指示该类或者接口有多少方法。\r\n\r\n> methods[]\r\n\r\n方法表的每个条目必须是`method_info`结构，用来表示一个方法的完整描述。如果结构中没有设置`ACC_NATIVE`或者`ACC_ABSTRACT`，那么方法的虚拟机指令实现也会被提供。\r\n\r\n> attributes_count\r\n\r\n指示该类属性的总数目。\r\n\r\n> attributes[]\r\n\r\n属性表的每个条目必须是`attribute_info`结构，用来表示一个属性的完整描述。属性表条目可以用来表示class文件的属性，也可以用来表示一个方法的属性。`attribute_info`的结构如下：\r\n\r\n    attribute_info {\r\n        u2 attribute_name_index; \r\n        u4 attribute_length; \r\n        u1 info[attribute_length];\r\n    }\r\n\r\n常量池表是class文件的资源仓库，与class文件中的其他item有着各种各样的联系。常量池表的第0号索引被空出来，用来在表示不引用任何常量池item的特殊含义。常量池中主要有两类常量：字面量和符号引用，字面量接近Java语言层面的常量概念，符号引用则属于编译原理方面的概念，主要包括package、Fully Qualified Name、Descriptor、Method Handle、Method Type、Invoke Dynamic、Dynamically-Computed Call Site、Dynamically-Computed Constant。\r\n\r\n类或者接口的名称在class文件中总是被表示为全限定类名的utf8编码形式，放在常量池的`CONSTANT_Utf8_info`结构中。而方法，字段，本地变量，形参则为非全限定类名的Unicode编码方式。\r\n\r\n类中的字段和方法的类型被一个叫descriptor的字符串来表示，其在常量池中是一个`CONSTANT_Utf8_info`结构。字段描述符被表示为FieldDescriptor:FieldType。Object类型的字段的描述符为Ljava/lang/Object,double[][][]类型的字段的描述符为[[[D，array类型不能超过255个维度。方法描述符被表示为：MethodDescriptor:( {ParameterDescriptor} ) ReturnDescriptor，比如Object m(int i, double d, Thread t) {...}的描述符为(IDLjava/lang/Thread;)Ljava/lang/Object;。\r\n\r\n常量池的每一项都是一个表，截至jdk18，共有17类表结构，这些表结构的第一项都是一个u1的tag，表示其是哪种类型的表结构。具体如下所示：\r\n|Constant Kind|Tag|\r\n|:-|:-|\r\n|CONSTANT_Class|7|\r\n|CONSTANT_Fieldref|9|\r\n|CONSTANT_Methodref|10|\r\n|CONSTANT_InterfaceMethodref|11|\r\n|CONSTANT_String|8|\r\n|CONSTANT_Integer|3|\r\n|CONSTANT_Float|4|\r\n|CONSTANT_Long|5|\r\n|CONSTANT_Double|6|\r\n|CONSTANT_NameAndType|12|\r\n|CONSTANT_Utf8|1|\r\n|CONSTANT_MethodHandle|15|\r\n|CONSTANT_MethodType|16|\r\n|CONSTANT_Dynamic|17|\r\n|CONSTANT_InvokeDynamic|18|\r\n|CONSTANT_Module|19|\r\n|CONSTANT_Package|20|\r\n\r\n所有类型的条目都遵循以下格式：\r\n\r\n    cp_info { \r\n        u1 tag;\r\n        u1 info[]; \r\n    }\r\n\r\n- CONSTANT_Class_info\r\n\r\n        CONSTANT_Class_info {\r\n            // 7  \r\n            u1 tag;\r\n\r\n            // 指向常量池表的某一项，该项为CONSTANT_Utf8_info结构\r\n            // 存储类的全限定类名\r\n            u2 name_index;  \r\n        }\r\n\r\n- CONSTANT_Fieldref_info\r\n\r\n        CONSTANT_Fieldref_info { \r\n            // 9\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构可表示一个类或者接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和字段描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_Methodref_info\r\n\r\n        CONSTANT_Methodref_info { \r\n            // 10\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个类\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_InterfaceMethodref_info\r\n\r\n        CONSTANT_InterfaceMethodref_info { \r\n            // 11\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_String_info\r\n\r\n        CONSTANT_String_info { \r\n            // 8\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info结构\r\n            // 该结构表示字符串对象的Unicode编码\r\n            u2 string_index; \r\n        }\r\n\r\n- CONSTANT_Integer_info\r\n\r\n        CONSTANT_Integer_info {\r\n            // 3 \r\n            u1 tag; \r\n\r\n            // 表示int值\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Float_info\r\n\r\n        CONSTANT_Float_info { \r\n            // 4 \r\n            u1 tag; \r\n\r\n            // 表示为IEEE754的单浮点数编码\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Long_info\r\n  \r\n        CONSTANT_Long_info { \r\n            // 5\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_Double_info\r\n  \r\n        CONSTANT_Double_info { \r\n            // 6\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_NameAndType_info\r\n\r\n        CONSTANT_NameAndType_info { \r\n            // 12\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法的名称\r\n            u2 name_index; \r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法描述符\r\n            u2 descriptor_index;\r\n        }\r\n\r\n- CONSTANT_Utf8_info\r\n\r\n        CONSTANT_Utf8_info { \r\n            // 1\r\n            u1 tag;\r\n\r\n            // byte数组的长度\r\n            u2 length; \r\n\r\n            // UTF-8编码\r\n            u1 bytes[length]; \r\n        }\r\n\r\n- CONSTANT_MethodHandle_info\r\n\r\n        CONSTANT_MethodHandle_info { \r\n            // 15\r\n            u1 tag;\r\n\r\n            // 表示方法句柄的类型，该类型会影响字节码的行为\r\n            // 1.REF_getField 2.REF_getStatic 3.REF_putField\r\n            // 4.REF_putStatic 5.REF_invokeVirtual 6.REF_invokeStatic\r\n            // 7.REF_invokeSpecial 8.REF_newInvokeSpecial 9.REF_invokeInterface\r\n            u1 reference_kind; \r\n\r\n            // 根据reference_kind的值，指向常量池中的某CONSTANT_Fieldref_info\r\n\r\n            // CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info结构\r\n            u2 reference_index;\r\n        }\r\n\r\n- CONSTANT_MethodType_info\r\n\r\n        CONSTANT_MethodType_info { \r\n            // 16\r\n            u1 tag;\r\n\r\n            // 指向常量池中的某表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n        }\r\n\r\n- CONSTANT_Dynamic_info （表示一个动态调用计算出的常量）\r\n\r\n        CONSTANT_Dynamic_info { \r\n            // 17\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示字段描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_InvokeDynamic_info （表示一个动态计算出的方法调用）\r\n  \r\n        CONSTANT_InvokeDynamic_info { \r\n            // 18\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示方法描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_Module_info\r\n\r\n        CONSTANT_Module_info { \r\n            // 19\r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示模块名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n\r\n- CONSTANT_Package_info\r\n\r\n        CONSTANT_Package_info {\r\n            // 20 \r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示包名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n    \r\nclass文件中fields数组中的条目都遵循`field_info`结构，数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n    field_info {\r\n        // 掩码标记，指示访问权限以及属性\r\n        // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED\r\n        // ACC_STATIC、ACC_FINAL、ACC_VOLATILE\r\n        // ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM\r\n        u2 access_flags; \r\n\r\n        // 指向常量池中一个表示字段名的CONSTANT_Utf8_info结构\r\n        u2 name_index;\r\n\r\n        // 指向常量池中一个表示字段描述符的CONSTANT_Utf8_info结构\r\n        u2 descriptor_index; \r\n\r\n        // 字段额外属性数组的大小\r\n        u2 attributes_count;\r\n\r\n        // attribute_info结构的数组\r\n        attribute_info attributes[attributes_count]; \r\n    }\r\n\r\nclass文件中methods数组中的条目都遵循`method_info`结构，每个条目表示一个方法，一个实例初始化方法，或者一个类初始化方法。数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n        method_info { \r\n            // 掩码标记，指示访问权限以及属性\r\n            // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC\r\n            // ACC_FINAL、ACC_SYNCHRONIZED、ACC_BRIDGE、ACC_VARARGS\r\n            // ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT、ACC_SYNTHETIC\r\n            u2 access_flags; \r\n\r\n            // 指向常量池中一个表示方法，<init>方法或者<clinit>方法的CONSTANT_Utf8_info结构\r\n            u2 name_index;\r\n\r\n            // 指向常量池中一个表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n\r\n            // 方法额外属性数组的大小\r\n            attributes_count;\r\n\r\n            // attribute_info结构的数组\r\n            attribute_info attributes[attributes_count]; \r\n        }\r\n\r\nattributes被用在class文件，field_info，method_info，Code_attribute，record_component_info结构中。field_info结构如下：\r\n\r\n        attribute_info {\r\n            // 指向常量池中一个表示属性名的CONSTANT_Utf8_info结构\r\n            u2 attribute_name_index; \r\n\r\n            // 表示附加属性的字节长度\r\n            u4 attribute_length;\r\n\r\n            // 附加属性\r\n            u1 info[attribute_length];\r\n        }\r\n\r\n附加属性相关的东西就说来话长了，有时间在写吧。"}},{"title":"functional programming","payload":{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"],"categories":"theory","content":"\r\n\r\n> 函数式编程是一种编程范式，区别于面向对象编程和面向过程编程的命令风格，其风格是声明式的，是满足若干要素的构建软件的方式。\r\n\r\n函数式编程由纯函数的组合构成，以避免共享状态、可变数据以及副作用。理解函数式编程的第一步就是要理解什么是纯函数。\r\n\r\n所谓纯函数就是那种对于给定输入总是得出固定输出且不产生任何副作用的函数。纯函数是函数的一种类型，一个函数的目的可以是值映射，一系列步骤的组合或者是同系统中的其他模块通信。纯函数总是和值映射相关，一个参数，一个固定输出。比如Math.max(11,13)无论被调用多少次，什么时候调用，其结果都是13。而且因为该函数不存在将值存盘或者输出到标准输出上的行为，理论上来说，只要Math.max(11,13)出现的地方，都可以用13去代替。即所谓的引用透明性(referential transparency)。Math.random(),System.currentTime()不是纯函数，因为它们不满足一个输入对应一个输出的原则。\r\n\r\n纯函数用副本实现不可变性的。区别于全拷贝，它将数据分成一个个很小的块，只对变化的块进行复制，很象git管理库和提交的方式。基于不可变性，纯函数也不会修改任何外部状态。\r\n\r\n纯函数不修改外部状态避免了共享状态，也意味着不会产生任何副作用。在共享状态下，并发/并行过程 + 可变状态 = 不确定性，一个不确定的系统结果是无法预测的，可能会产生各种奇奇怪怪的bug，纯函数可以帮助我们避免这种bug。\r\n\r\n函数组合就是将两个以上的函数以某种顺序组合成一个函数的过程，一个函数就像是一个管道，我们的数据就在这一系列的管道中流过。基于这种风格，我们可以减少中间变量的使用。\r\n\r\n函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象的编程倾向于将方法和数据放在对象中。那些并置的方法只能对它们设计用于操作的数据类型进行操作，并且通常只能对包含在该特定对象实例中的数据进行操作。在函数式编程中，任何类型的数据都是平等的。相同的 map()实用程序可以映射对象、字符串、数字或任何其他数据类型，因为它将函数作为参数来适当地处理给定的数据类型。函数式编程使用高阶函数实现了它的通用实用技巧。\r\n\r\n更加具体清晰的functional programming说明可以参考Eric Elliott的文章[Master the JavaScript Interview: What is Functional Programming?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0),以及Russ Olsen的演讲[Functional Programming in 40 Minutes](https://www.youtube.com/watch?v=0if71HOyVjY)。\r\n"}},{"title":"reactive programming","payload":{"title":"reactive programming","date":"2022-05-11","tags":["reactive","编程风格"],"categories":"theory","content":"\r\n\r\n"}},{"title":"123.买卖股票的最佳时机Ⅲ","payload":{"title":"123.买卖股票的最佳时机Ⅲ","date":"2022-05-03","tags":["leetcode"],"categories":"leetcode","content":"\r\n\r\n> 题目描述\r\n\r\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n\r\n> 例1\r\n\r\n    输入：prices = [3,3,5,0,0,3,1,4]\r\n    输出：6\r\n    解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\r\n    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候 卖出，这笔交易所能获得利润 = 4-1 = 3 。\r\n> 例2\r\n\r\n    输入：prices = [1,2,3,4,5]\r\n    输出：4\r\n    解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \r\n    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出.因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\r\n> 例3\r\n\r\n    输入：prices = [7,6,4,3,1] \r\n    输出：0 \r\n    解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\r\n\r\n思路：我们可做的交易数为0，1，2，也就是说最多可以做两笔交易。那么我们可以以第i天为界，计算出[0 - i]最大收益数和[i - n]最大收益数之和，得到的结果就是我们想要的答案。<div align=\"center\"><img src=\"../resources/img/leetcode_123_1.jpg\"></div>\r\n\r\n附上代码\r\n\r\n    //123.买卖股票的最佳时机 III\r\n    public int maxProfit(int[] prices) {\r\n        int ans = 0;\r\n        int len = prices.length;\r\n        //前i + 1天所能得到的最大收益\r\n        int[] beforeProfits = new int[len];\r\n        int min = prices[0],max = prices[0];\r\n        for (int i = 1; i < len; i++) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            beforeProfits[i] = Math.max(beforeProfits[i - 1],prices[i] - min);\r\n        }\r\n        min = prices[len - 1];\r\n        max = prices[len - 1];\r\n        //后n - i天所能得到的最大收益\r\n        int[] afterProfits = new int[len];\r\n        for (int i = len - 2; i >= 0; i--) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            afterProfits[i] = Math.max(afterProfits[i + 1],max - prices[i]);\r\n        }\r\n        for (int i = 0; i < len; i++) {\r\n            ans = Math.max(ans,beforeProfits[i] + afterProfits[i]);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n"}},{"title":"42.接雨水","payload":{"title":"42.接雨水","date":"2022-05-03","tags":["leetcode"],"categories":"leetcode","content":"\r\n\r\n> 题目描述\r\n\r\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\r\n\r\n> 例1\r\n\r\n    输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\r\n    输出：6\r\n\r\n> 例2\r\n\r\n    输入：height = [4,2,0,3,2,5]\r\n    输出：9\r\n\r\n> 思路\r\n\r\n- 首先找出所有的制高点，所谓制高点就是广义极大值点\r\n- （关键）以每个制高点为左边界，找到其右边界。具体做法是沿着制高点数组向右找第一个大于等于的制高点作为右边界，如果找到头也没找到，则把其中最大的作为右边界\r\n- 从最左制高点开始将其作为左边界，将上一步找到的其右边界作为右边界，找到它们当中的较低点作为水平面值，从此点开始向左或者向右将深度加到结果中去，直到遇到某处的高度大于水平面值为止。之后将右边界作为左边界循环此步，直到边界抵达最右制高点。\r\n\r\n> 附上代码\r\n\r\n    public int trap(int[] height) {\r\n        int ans = 0;\r\n        int len = height.length;\r\n        if(len == 1){\r\n            return ans;\r\n        }\r\n        //制高点list\r\n        List<Integer> list = new ArrayList<>();\r\n        //将所有制高点的数组下标按顺序放入list中\r\n        if(height[0] >= height[1]){\r\n            list.add(0);\r\n        }\r\n        for (int i = 1; i < len - 1; i++) {\r\n            if(height[i] >= height[i - 1] && height[i] >= height[i + 1]){\r\n                list.add(i);\r\n            }\r\n        }\r\n        if(height[len - 1] >= height[len - 2]){\r\n            list.add(len - 1);\r\n        }\r\n        int size = list.size();\r\n        //所有制高点的右边界的list下标\r\n        int[] rightFirstHigher = new int[size];\r\n        rightFirstHigher[size - 1] = size;\r\n        //关键步骤，从右向左找到所有制高点的右边界的list下标\r\n        for (int i = size - 2; i >= 0; i--) {\r\n            //next期望找到第一个大于等于当前制高点的下标，nextI为未找到next前小于当前制高点的最高点的下标\r\n            int h = height[list.get(i)],next = i + 1,nextI = i + 1;\r\n            while (next < size && height[list.get(next)] < h){\r\n                if(height[list.get(next)] > height[list.get(nextI)]){\r\n                    nextI = next;\r\n                }\r\n                next = rightFirstHigher[next];\r\n            }\r\n            //没找到，右边界为nextI，否则为next\r\n            rightFirstHigher[i] = next == size ? nextI : next;\r\n        }\r\n        //统计各区间的水量\r\n        for (int i = 0; i < size - 1; i=rightFirstHigher[i]) {\r\n            int left = list.get(i),right = list.get(rightFirstHigher[i]);\r\n            int min = Math.min(height[left],height[right]);\r\n            if(height[left] < height[right]){\r\n                for (int j = left + 1; j < right; j++) {\r\n                    //保证不大于水平面高度\r\n                    if(height[j] > min){\r\n                        break;\r\n                    }\r\n                    ans += min - height[j];\r\n                }\r\n            }else {\r\n                for (int j = right - 1; j > left; j--) {\r\n                    if(height[j] > min){\r\n                        break;\r\n                    }\r\n                    ans += min - height[j];\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n时空间复杂度感人:joy:\r\n"}},{"title":"使用redis实现分布式锁","payload":{"title":"使用redis实现分布式锁","date":"2022-04-29","tags":["redis","分布式锁"],"categories":"中间件","content":"\r\n\r\n## 使用redis实现分布式锁\r\n\r\n>同一操作系统下的线程竞态访问某一临界资源，我们可以使用锁来帮助我们达成目的，一些编程语言\r\n都会提供内置的锁库。但是当我们的执行线程并不运行在同一操作系统之下，单一实例下的锁机制就\r\n失效了，这种情况下，我们需要分布式锁机制来帮助我们协调管理线程之间的竞争。\r\n\r\n我们可以在redis的帮助下实现分布式锁机制。只需要一条简单的命令我们便能做到它。\r\n\r\n    set resource_name unique_value NX;\r\n在我们进入临界区之前，先尝试着向redis中插入一条数据，若该数据存在则获取锁失败，否则获取\r\n锁成功。不过这里有一个问题，就是若获取锁的线程在释放锁之前挂了，那么锁就无法被释放，其他线程\r\n也就没有办法获取到锁。为了解决这个问题，我们可以将unique_value设置为`expire_timestamp`，\r\n另外的线程可以get到`expire_timestamp`，若该时间戳小于当前时间戳，我们便可以执行del命令进而\r\n释放到锁，再执行获取锁的指令，就ok了。然而虽解决了锁无法释放的问题，却引入了新的问题。这里\r\n我们假设有两个线程在同一时刻检测到了锁失效，然后相继执行释放锁加锁的步骤，像下面这样：\r\n\r\n    Thread 1:del resource_name;\r\n    Thread 1:set resource_name unique_value NX;\r\n    Thread 2:del resource_name;\r\n    Thread 2:set resource_name unique_value NX;\r\n最终Thread1和Thead2都获得了锁，违反了分布式锁的含义。因此相应的，我们不应该将释放锁的权力\r\n交给其他线程。释放锁的工作应当由获取锁的线程去做，若该线程挂了，那么该锁应当超时自动释放，redis\r\n同样提供了这样的机制，将上面的改一改：\r\n\r\n    set resource_name unique_value NX EX expire_time;\r\n即使获取锁的线程挂了，该锁也能够在超时之后释放掉。但是呢，这个命令还是有问题。假设这把锁被超时释放了，\r\n另外的线程又获取到了这把锁，然而之前获取锁的线程并没有挂掉，它只是执行的比较慢而已，在另一个线程获取锁\r\n之后它才执行释放锁的操作，然后它就把其他线程的锁给释放掉了。显然这是不符合逻辑的，上面就提到没有把持锁\r\n的线程没有释放锁的权力，那么这个时候unique_value就起到了作用，当我们获取锁的时候将键对应的值设为\r\n全局唯一的某个值，比如timestamp + clientId，然后我们可以写一段Lua脚本\r\n\r\n    if redis.call(\"get\",KEY[1]) == ARGV[1]\r\n    then\r\n        return redis.call(\"del\",KEY[1])\r\n    else\r\n        return 0\r\n    end\r\n只有当对应的值与当前线程设的值一样时，当前线程才可以释放掉锁。redis内置的lua脚本解释器也保证了\r\n每段脚本执行的原子性，不必担心有其他意外发生。\r\n\r\n这些看起来很美好，但是不幸的是，依旧存在问题。如果我们的redis是master-slave架构，某个时刻master挂了，\r\n由于master和slave之间是异步的，如果新选出来的master没有这条锁的记录，那么其他线程便能够获取到该锁。那么\r\n有没有什么办法可以解决这个问题呢，答案是有的，大名鼎鼎的redlock就是为此诞生的。由于精力有限，redlock的讨论\r\n就过段时间再说，这里先挖个坑。\r\n"}},{"title":"编程相关小技巧","payload":{"title":"编程相关小技巧","date":"2022-04-29","tags":["技巧"],"categories":"技巧","content":"\r\n目前内容较少，没有分篇叙述的必要，预计达到100个`tip`开分\r\n\r\n1. 在vscode中编写markdown文档时自动换行\r\n> - ctrl + shift + p,打开命令窗口，输入setting，打开open user settings\r\n> - 在搜索栏中搜索markdown\r\n> - 将Markdown>Preview：Breaks打上勾就ok了\r\n"}},{"title":"rabbitmq与AMQP","payload":{"title":"rabbitmq与AMQP","date":"2022-05-01","tags":["消息队列","中间件","rabbitmq"],"categories":"中间件","content":"\r\n\r\nrabbitmq是一款被广泛使用的消息队列中间件，它目前被Pivotal公司所拥有。其基于`AMQM`、`AMQP`并用`erlang`语言实现，拥有诸多特性，譬如开源、强大商业支持、跨语言、跨平台、轻量级、扩展性强、可定制、安全支持等。它可以通过分布式部署满足高可用的需求，其吞吐量亦十分可观，能够达到万/s的级别，当然吞吐量的高的代价是比较吃cpu，我们可以根据自身系统在可用性和性能两方面做权衡。另外rabbitmq还支持异地多活和异地多活多主架构。\r\nrabbitmq强悍的力量很大程度上是因为其基于`AMQP`，`AMQP`不仅定义了网络层协议而且对服务端的服务和行为也做了定义，即`AMQ model`。`AMQ model`就消息路由行为定义了三个抽象组件：`Exchange,Queue,Binding`。\r\n- Exchange：将消息路由给队列的组件\r\n- Queue：存在于内存或者磁盘中的存储消息的数据结构\r\n- Binding：Exchange将消息分发给Queue的规则\r\n\r\n将一个message发送到broker后，broker的行为如下图所示：<div align=\"center\"><img src=\"../../resources/img/rabbitmq-message-send.jpg\"></div>\r\n\r\n实际使用时，每种Exchange类型处理routing-key的行为会有所差异，有的不做任何处理，有些则需要进行复杂的模式匹配提取，header exchange甚至根本就不管routing-key是啥。rabbitmq在设计中扩展了AMQ model，exchange不仅接受queue的绑定，而且接受其他exchange的绑定，这种特性为消息的路由模式提供了相当的灵活性。\r\n\r\nrabbitmq客户端库的实现都会隐藏掉基于AMQP进行通信的复杂性，这或许对用户来说是一件好事，用户的绝大多数精力可以用在应用层上，不必关心实际上的复杂性。但我们还是应当熟悉AMQP协议，只有这样，我们才不会在应用性能没有达到预期或者是出现错误时束手无策。\r\n\r\nrabbitmq利用`RPC`模式实现AMQP的通信，但是具体实现又同一般的RPC模式有所不同。一般来说，进行RPC通信的双方，客户端发送指令给服务端，服务端处理后返回响应，这里服务端是不会发指令给客户端的，但是rabbitmq的RPC实现中，服务端会。<div align=\"center\"><img src=\"../../resources/img/rabbitmq-conversation.jpg\" height=600px></div>\r\n\r\nrabbitmq客户端与服务端之间建立通信首先需要经过三次握手。首先客户端会发送包含Protocol Header的Greeting给服务端，接着服务端发送Connection.Start给客户端，最后客户端发送Connection.StartOk给服务端，之后一个连接就建立了。在客户端与服务端之间进行有实际意义的交流之前，还得在连接中打开channel，在channel中进行AMQP帧的传输。channel是双工的，并且可以在一个连接中有多个，有点像HTTP2。\r\n\r\nAMQP的命令由类和方法组成，像Connection.Start中，Connection是对象，Start是方法。当命令被发送到客户端或者服务端时，执行命令所需的参数被封装到帧中进行传输。底层的AMQP帧大致上长这样。<div align=\"center\"><img src=\"../../resources/img/amqp-frame.jpg\" ></div>\r\n\r\n帧的头部由帧类型，channe编码，payload大小组成。有五种帧的类型如下所示：\r\n- protocol header frame：只会在在连接到rabbitmq时用到\r\n- method frame：携带RPC请求或者响应\r\n- content header frame：包含消息的大小和属性\r\n- body frame：消息内容\r\n- heartbeat frame：心跳检测确认通信双方存活\r\n\r\n在channel中的数据总是以`method frame`，`content header frame`，多个`body frame`的顺序流动。method frame被特殊编码以压缩大小，典型的method frame头两个字段包含类型和方法，之后的一个字段是exchange name，再然后是routing-key，最后可能会有一个mandatory字段以让rabbitmq在没有满足消息发布需求时给客户端进行反馈。content header frame的payload主体由Basic.Properties表组成，通过它可以很方便的实现消息的定制化。content header frame也会被特殊编码。body frame则不会被特殊编码，它可以装载各种格式的图片，json/xml格式数据或者是文档等。\r\n\r\n在AMQ model中，`exchange`和`queue`都是一等公民。创建一个exchange对应的method是Exchange.Declare,如果创建成功，rabbitmq会返回Exchange.DeclareOk,否则会返回Channel.Close。类似的，创建一个queue对应的method是Queue.Declare,如果创建成功，rabbitmq会返回Queue.DeclareOk,否则会返回Channel.Close。将一个queue绑定到exchange的method是Queue.Bind,绑定成功，rabbitmq会返回Queue.BindOk。以上的method在AMQP中都是同步命令，在AMQP中也有一些命令通过异步的方式来接受和发送消息。\r\n\r\n当我们通过Basic.Publish发布消息到rabbitmq中时，可以将消息存储到内存或者是磁盘中去，并且只会储存一份，丢到队列中的实际是实例的一份引用，不同队列的实例引用之间互不影响。当我们把消息丢到队列中去之后，剩下的就是消费了，客户端发送Basic.Consume请求消费，然后rabbitmq响应Basic.ConsumeOk表示可以开始消费，若客户端想要终止消费过程，可以发送Basic.Cancel,这是一个异步命令，所以客户端此时还是会收到rabbitmq发来的消息。\r\n\r\n受限于精力，能力和时间成本，rabbitmq的AMQP实现的了解暂时先到此为止。如果想进一步了解，可以参考[rabbitmq的官方文档](https://www.rabbitmq.com/protocol.html)。\r\n\r\n附上Basic.Properties的属性表：<div align=\"center\"><img src=\"../../resources/img/Basic-properties.png\"></div>\r\n"}},{"title":"rabbitmq中的消息发布与消费","payload":{"title":"rabbitmq中的消息发布与消费","date":"2022-05-02","tags":["rabbitmq"],"categories":"中间件","content":"\r\n>多一分则肥，少一分则瘦\r\n\r\n消息中间件消息的发布需要在高性能与可靠性之间做权衡，rabbitmq依靠AMQP的事务规范，可选的持久化机制，以及自身的传输确认机制为我们构建不同等级的可靠系统提供了可能性。<div align=\"center\"><img src=\"../../resources/img/performance-with-guarantee.png\"></div>\r\n\r\nNotification on failure -- 当我们在Basic.Publish的method frame中添加mandatory标志时，如果消息没有被正确的路由，那么rabbitmq broker就会通过Basic.Return的RPC回传消息给publisher。在我们的代码中要注册回调函数处理这种路由失败的情况。Publisher confirms -- publisher发送Confirm.Select,rabbitmq broker回复Confirm.SelectOk，之后这条传递消息的channel就成了一个confirm channel，publisher每发送一条消息给服务器，如果消息都入队等待被消费并且被持久化到磁盘中，或者是消息在所有应该路由到的队列中都被消费者消费完毕了，服务端就会回复Basic.Ack，否则就会回复Basic.Nak。服务端异步回复confirm消息，在我们的代码中需要注册回调函数处理来自服务端的回复。Alternate exchanges -- 当我们声明一个exchange，可以给它绑定一个备用exchange，当发送给给此exchange的消息无法被路由时，此备选exchange就会接管工作，将消息路由到死信队列中去，值得注意的是，一旦同时设置mandatory标志和备选队列，那么mandatory就失效了。Transactions -- AMQP规范中定义了事务来保证批处理的原子性。publisher发送TX.Select,服务端回传TX.SelectOk，事务就开始了，可以在事务中发送一条或者多条消息，消息发送完毕publisher发送TX.Commit，然后在收到服务端的TX.CommitOk后，事务就完成了。这里需要注意的是当事务执行过程中，发生错误了，那么服务端就会发送Basic.Return,publisher如果想终止事务，可以发送TX.Rollback，然后等待服务端回传TX.RollbackOk。另外，rabbitmq在实现AMQP事务规范时只有当命令只影响一条队列时，才保证其原子性，当有多条队列收到影响时，原子性就会被打破。事务机制比较影响性能。HA queues -- HA queue需要在集群环境中使用，在定义队列时，将队列声明为高可用队列，模式若设为all，则集群中的所有结点都会同步此队列的状态。若模式为nodes，则可自定义同步节点。一旦消费者在任意节点消费了此队列中的消息，所有节点中的该条消息就会立刻被删除。HA queues拥有一个主节点，其他的都是副节点，如果主节点挂了，其他的某个副节点就会成为新的主节点。如果挂了的节点恢复了，或者集群中加入了新的节点，那么它们会接受新发送来的消息，并且在队列中的旧消息都消费完毕了才会加入同步集。HA queues with transactions -- 这种方式会引入相当的响应延迟，慎重使用。Persisted messages -- 持久化选项由Basic.Properties中的delivery-mode控制，默认为1，表示不持久化，如果想要持久化，则应该设为2，另外装此消息的队列也应该被设置为持久化队列。\r\n\r\n上面一段讲了向rabbitmq发布消息的问题，这一段我们看看怎么从rabbitmq获取消息。有两种方法可以从rabbitmq获取消息，`Basic.Get` & `Basic.Consume`。Basic.Get使用一种拉的模式从broker中获取消息，consumer想要获取一个消息都必须发送一个新的Basic.Get RPC请求，broker会根据queue中是否有代办消息回复`Basic.GetOk` or `Basic.GetEmpty`，消费端需要根据回复进行相应的处理。Basic.Get的这种同步方式对性能有明显的影响，更重要的是，由于consume是消费端主动发起的，所以broker也无法优化整个传输过程。与`Basic.Get`相反的是，`Basic.Consume`以一种推的方式从broker中获取消息，发送Basic.Consume RPC请求到broker后，rabbitmq就会在broker中注册你的应用，然后直到你发送`Basic.Cancel`之前,broker都以一种异步的方式将队列中的消息发送给消费者。当然从broker获取到消息之后，消费端也需要向broker发送`Basic.Ack`让它知道消息已经被正常消费了。同publish一样，消费消息也需要在吞吐量和可靠性之间做权衡。<div align=\"center\"><img src=\"../../resources/img/consume-with-guarantee.png\"></div>\r\n\r\nno-ack -- 当向rabbitmq发送Basic.Consume注册我们的应用进行消费时，在请求中携带no-ack的标志时，broker就会知道消费端不会ack，应该尽可能快速地将消息发送给消费端。Consuming with acknowledgement and Qos > 1 -- 通过向broker发送Basic.Qos请求，我们可以设置一条channel的服务质量，broker会在这条channel上连续发送预设数量的message后，等待消费端的回复，消费端可以选择依旧每条消息都回复，也可以通过在Basic.Ack中设置multiple标志而不必每条消息都回复，broker会将没有收到回复的消息写回到队列中。当然设置multiple标志的方式会有重复消费的风险。transaction -- 事务方式可以规避重复消费的风险，代价是吞吐量不及QoS的方式。\r\n\r\n当消费端在接收消息或者处理消息的过程中发生异常情况时，rabbitmq提供两种方式将消息踢还给broker：`Basic.Reject` & `Basic.Nak`。发送Basic.Reject给服务端时，若在请求中携带requeue标志，则broker会将消息重新入队，否则broker只是简单的将消息丢弃。Basic.Nak的行为与Basic.Reject类似，不同的是其类似Basic.Ack可以在一次回复中携带多个拒绝信息，它也不是AMQP原生支持的命令。除了这两条命令，rabbitmq还提供叫做死信exchange(DLX)的扩展，DLX同队列进行绑定，一个队列中被拒绝且没有重新入队的消息或者过期的消息会被交给DLX。"}},{"title":"rabbitmq中的队列和exchange","payload":{"title":"rabbitmq中的队列和exchange","date":"2022-05-02","tags":["rabbitmq","中间件","消息队列"],"categories":"中间件","content":"\r\n\r\n队列毫无疑问在消息队列中占据着核心地位，rabbitmq提供了诸多设置让我们能够自如地定义队列。这些设置有很多，挑一些常用的列举在下方：\r\n- 自动删除\r\n- 限制唯一消费者消费\r\n- 自动过期队列\r\n- 限制消息的数量\r\n\r\n非常重要的是，一旦我们创建了一个队列，队列的设置就无法被更改了，改变队列的设置只能通过删除然后重新创建的方式。\r\n\r\n通过在`Queue.Declare`请求中加入`auto_delete`标志可以创建临时队列，所谓临时队列就是一旦消费者拿走队列的全部消息、断开连接，队列就会被删除。值得留意的是，临时队列可以被任意数量的消费者消费，只有当不再有消费者监听该队列了，这个队列才会被删除。\r\n\r\n在队列声明请求中加入`exclusive`标志可以限制消费者的数量为一，声明一个排他队列，排他队列也会自动删除，但它的行为和临时队列有所不同，排他队列在连接断开后被删除，临时队列则与是否有订阅者有关。\r\n\r\n通过在队列声明请求中加入`x-expires`参数可以声明一个定时队列，参数单位为毫秒，定时队列会在过期时间到后被自动删除，需要注意的是只要定时队列上由消费者，那么除非消费者停止订阅或者连接断开，该队列是不会被自动删除的。另外当消费者向该队列发送`Basic.Get`请求后，`x-expires`参数就失效了，该队列不再是定时队列了。rabbitmq不保证删除定时队列的及时性。\r\n\r\n通过在创建队列请求中将`durable`参数置为true，可以让该队列成为一个永久队列，并被持久化到磁盘中去，直到`Queue.Delete`命令删除该队列。\r\n\r\n通过在创建队列时设置`x-message-ttl`可以设置队列中消息的过期时间，设置`x-max-length`可以设置队列最大消息数，当队列中的消息达到了这个数目，就无法向队列中添加消息了。如果该队列声明了`DLX`，那么过期的消息和无法添加的消息会被交给`DLX`处理。\r\n\r\n声明一个队列可使用的参数及其作用如下图所示：<div align=\"center\"><img src=\"../../resources/img/queue-argument.png\"></div>\r\n\r\nrabbitmq最强大的力量来自于exchange基于消息中的routing信息将消息路由至不同队列的灵活性。通过exchange，消息可以被路由至一个或多个队列，其他exchange，还可以是外部资源。在rabbitmq中有四种类型的exchange：\r\n- Direct exchange\r\n- Fanout exchange\r\n- Topic exchange\r\n- Headers exchange\r\n\r\nDirect exchange是rabbitmq中最简单的exchange，它可以被多个队列绑定，当消息发送至此exchange时，它会将消息的routing-key同与之绑定的队列的binding-key做比较，只有当两个字符串完全相等时，exchange才会将消息丢到队列中去。\r\n\r\nFanout exchange会将接受的消息发送到所有绑定的队列中去，因为不需要进行routing-key和binding-key的比较，所有性能会很好，但是也因为缺乏选择机制，路由至所有队列中的消息都应该被消费。\r\n\r\nTopic exchange同Direct exchange一样会基于routing-key选择性的路由消息到队列中，不同的是Topic exchange不需要完全匹配，它通过基于通配符的模式匹配完成工作。\r\n\r\nHeaders exchange的允许在消息中自描述路由逻辑，在消息头的Basic.Properties中添加headers属性，headers表随意添加key/value对，队列与exchange的绑定使用的也不再是字符串数组，而是key/value对的数组，绑定会被设置一个叫x-match的参数，值为any或者all，any表示任意匹配，all则是全匹配。Headers exchange提供强大的路由机制，但代价是也给broker带来了额外的计算负担，在比较路由之前，headers表中的属性值会先被排序。但是有一点需要注意的是只要在消息的属性中设置了headers，那么无论消息被发送至什么类型的exchange上，性能都会受到影响。\r\n\r\n一个exchange可以有多个queue绑定，那么一个消息可以被发送至多个exchange吗？答案是可以的。通过exchange-to-exchange绑定，你可以做到这一切，不同于队列绑定使用Queue.Bind method，exchange绑定使用Exchange.Bind method。这种机制非常灵活，灵活可能会使系统变得复杂。rabbitmq中的主要exchange类型如下图所示：<div align=\"center\"><img src=\"../../resources/img/exchanges.png\"></div>"}}];
export const categoriesAll = ["Java","随笔","theory","leetcode","中间件","技巧"];
export const categoriesMap = [{"category":"Java","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"category":"随笔","payload":[{"title":"观‘技术人不要看中文’有感","date":"2022-04-29","tags":["essay"],"categories":"随笔","content":"\r\n\r\n今日B站给推送一个视频，标题叫‘[50岁程序员：技术人不准看中文！](https://www.bilibili.com/video/BV1Sr4y1J7K9?spm_id_from=333.999.0.0)’ 。短短25秒大致意思就是中文互联网下所获取学习到的相关技术已经比其原本所具备的能力打了折扣。评论最高赞的三个评论我贴在下方。![反对方论点](../resources/img/journal_review1.png)  ![支持方论点](../resources/img/journal_review2.png)\r\n\r\n就我个人来说，技术人不准看中文大致上是准确。诚然，中文互联网上是可以找到大量优质的技术文章，它们或者短小精悍，或者详尽有趣，看完也能大有收获。但是呢，这里有一个问题，我怎么才能找到这些文章呢？对于一个小白来说代价有点大。遇到问题，借助百度，搜到的答案要么同质化程度太高，要么水平低下，要么早已过时。(google好一些，但或多或少还是会遇到这种情况，怎么解决还有待探索)。一些技术论坛，rss的情况好一些，可以时不时的找到一些高质量文章，有时在评论区也能有所收获，但也都是随缘，毕竟这些生产高质量文章的大佬一是更新日期不固定，二是实时的关注点也会有所差异。当然我们也可以去看书，这里有两类，一类是由英文翻译而来的技术书，一类是中文作者原创的技术书。中文原创的技术书一般都是实战型，就着某个框架，某门技术给你现造个应用出来，这么做其实好的，编程这个东西就得实践，看一百本书都比不上做一个完整项目的收获大。但是这么做也是有问题的，一本几百页的书并且是在以项目为基础的前提下所能包含的相关技术的内涵是有限的，而且这些书一般也会绑定某个版本做项目，当我们要换个版本做应用，并且版本的变化相对较大时，我们还是得去看官方的文档，这些文档鲜少会提供中文。至于由英文翻译而来的技术书呢，则良莠不齐，有些甚至都可以看出是机翻。\r\n\r\n所以对于反对者所说的看英文文档效率低的问题我是不认同的，相对与在中文互联网中四处闲逛还是收获甚小所造成的开销，翻译层的开销是可以忽略的。至于后半段真假参半的话术，还扯上脊梁问题，那就令人反感了。这里为什么说真假参半呢，因为这里是有指导意义的，读应当读英文，那些大佬有空也可以做一些优秀的中文输出反馈到中文社区，从而形成中文互联网的良性循环。虽然在这个流量变现，而不是付费变现的时代，期待这成为现实有些困难，但万一呢 :wink: "}]},{"category":"theory","payload":[{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"],"categories":"theory","content":"\r\n\r\n> 函数式编程是一种编程范式，区别于面向对象编程和面向过程编程的命令风格，其风格是声明式的，是满足若干要素的构建软件的方式。\r\n\r\n函数式编程由纯函数的组合构成，以避免共享状态、可变数据以及副作用。理解函数式编程的第一步就是要理解什么是纯函数。\r\n\r\n所谓纯函数就是那种对于给定输入总是得出固定输出且不产生任何副作用的函数。纯函数是函数的一种类型，一个函数的目的可以是值映射，一系列步骤的组合或者是同系统中的其他模块通信。纯函数总是和值映射相关，一个参数，一个固定输出。比如Math.max(11,13)无论被调用多少次，什么时候调用，其结果都是13。而且因为该函数不存在将值存盘或者输出到标准输出上的行为，理论上来说，只要Math.max(11,13)出现的地方，都可以用13去代替。即所谓的引用透明性(referential transparency)。Math.random(),System.currentTime()不是纯函数，因为它们不满足一个输入对应一个输出的原则。\r\n\r\n纯函数用副本实现不可变性的。区别于全拷贝，它将数据分成一个个很小的块，只对变化的块进行复制，很象git管理库和提交的方式。基于不可变性，纯函数也不会修改任何外部状态。\r\n\r\n纯函数不修改外部状态避免了共享状态，也意味着不会产生任何副作用。在共享状态下，并发/并行过程 + 可变状态 = 不确定性，一个不确定的系统结果是无法预测的，可能会产生各种奇奇怪怪的bug，纯函数可以帮助我们避免这种bug。\r\n\r\n函数组合就是将两个以上的函数以某种顺序组合成一个函数的过程，一个函数就像是一个管道，我们的数据就在这一系列的管道中流过。基于这种风格，我们可以减少中间变量的使用。\r\n\r\n函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象的编程倾向于将方法和数据放在对象中。那些并置的方法只能对它们设计用于操作的数据类型进行操作，并且通常只能对包含在该特定对象实例中的数据进行操作。在函数式编程中，任何类型的数据都是平等的。相同的 map()实用程序可以映射对象、字符串、数字或任何其他数据类型，因为它将函数作为参数来适当地处理给定的数据类型。函数式编程使用高阶函数实现了它的通用实用技巧。\r\n\r\n更加具体清晰的functional programming说明可以参考Eric Elliott的文章[Master the JavaScript Interview: What is Functional Programming?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0),以及Russ Olsen的演讲[Functional Programming in 40 Minutes](https://www.youtube.com/watch?v=0if71HOyVjY)。\r\n"}]},{"category":"leetcode","payload":[{"title":"123.买卖股票的最佳时机Ⅲ","date":"2022-05-03","tags":["leetcode"],"categories":"leetcode","content":"\r\n\r\n> 题目描述\r\n\r\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n\r\n> 例1\r\n\r\n    输入：prices = [3,3,5,0,0,3,1,4]\r\n    输出：6\r\n    解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\r\n    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候 卖出，这笔交易所能获得利润 = 4-1 = 3 。\r\n> 例2\r\n\r\n    输入：prices = [1,2,3,4,5]\r\n    输出：4\r\n    解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \r\n    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出.因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\r\n> 例3\r\n\r\n    输入：prices = [7,6,4,3,1] \r\n    输出：0 \r\n    解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\r\n\r\n思路：我们可做的交易数为0，1，2，也就是说最多可以做两笔交易。那么我们可以以第i天为界，计算出[0 - i]最大收益数和[i - n]最大收益数之和，得到的结果就是我们想要的答案。<div align=\"center\"><img src=\"../resources/img/leetcode_123_1.jpg\"></div>\r\n\r\n附上代码\r\n\r\n    //123.买卖股票的最佳时机 III\r\n    public int maxProfit(int[] prices) {\r\n        int ans = 0;\r\n        int len = prices.length;\r\n        //前i + 1天所能得到的最大收益\r\n        int[] beforeProfits = new int[len];\r\n        int min = prices[0],max = prices[0];\r\n        for (int i = 1; i < len; i++) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            beforeProfits[i] = Math.max(beforeProfits[i - 1],prices[i] - min);\r\n        }\r\n        min = prices[len - 1];\r\n        max = prices[len - 1];\r\n        //后n - i天所能得到的最大收益\r\n        int[] afterProfits = new int[len];\r\n        for (int i = len - 2; i >= 0; i--) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            afterProfits[i] = Math.max(afterProfits[i + 1],max - prices[i]);\r\n        }\r\n        for (int i = 0; i < len; i++) {\r\n            ans = Math.max(ans,beforeProfits[i] + afterProfits[i]);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n"}]},{"category":"中间件","payload":[{"title":"使用redis实现分布式锁","date":"2022-04-29","tags":["redis","分布式锁"],"categories":"中间件","content":"\r\n\r\n## 使用redis实现分布式锁\r\n\r\n>同一操作系统下的线程竞态访问某一临界资源，我们可以使用锁来帮助我们达成目的，一些编程语言\r\n都会提供内置的锁库。但是当我们的执行线程并不运行在同一操作系统之下，单一实例下的锁机制就\r\n失效了，这种情况下，我们需要分布式锁机制来帮助我们协调管理线程之间的竞争。\r\n\r\n我们可以在redis的帮助下实现分布式锁机制。只需要一条简单的命令我们便能做到它。\r\n\r\n    set resource_name unique_value NX;\r\n在我们进入临界区之前，先尝试着向redis中插入一条数据，若该数据存在则获取锁失败，否则获取\r\n锁成功。不过这里有一个问题，就是若获取锁的线程在释放锁之前挂了，那么锁就无法被释放，其他线程\r\n也就没有办法获取到锁。为了解决这个问题，我们可以将unique_value设置为`expire_timestamp`，\r\n另外的线程可以get到`expire_timestamp`，若该时间戳小于当前时间戳，我们便可以执行del命令进而\r\n释放到锁，再执行获取锁的指令，就ok了。然而虽解决了锁无法释放的问题，却引入了新的问题。这里\r\n我们假设有两个线程在同一时刻检测到了锁失效，然后相继执行释放锁加锁的步骤，像下面这样：\r\n\r\n    Thread 1:del resource_name;\r\n    Thread 1:set resource_name unique_value NX;\r\n    Thread 2:del resource_name;\r\n    Thread 2:set resource_name unique_value NX;\r\n最终Thread1和Thead2都获得了锁，违反了分布式锁的含义。因此相应的，我们不应该将释放锁的权力\r\n交给其他线程。释放锁的工作应当由获取锁的线程去做，若该线程挂了，那么该锁应当超时自动释放，redis\r\n同样提供了这样的机制，将上面的改一改：\r\n\r\n    set resource_name unique_value NX EX expire_time;\r\n即使获取锁的线程挂了，该锁也能够在超时之后释放掉。但是呢，这个命令还是有问题。假设这把锁被超时释放了，\r\n另外的线程又获取到了这把锁，然而之前获取锁的线程并没有挂掉，它只是执行的比较慢而已，在另一个线程获取锁\r\n之后它才执行释放锁的操作，然后它就把其他线程的锁给释放掉了。显然这是不符合逻辑的，上面就提到没有把持锁\r\n的线程没有释放锁的权力，那么这个时候unique_value就起到了作用，当我们获取锁的时候将键对应的值设为\r\n全局唯一的某个值，比如timestamp + clientId，然后我们可以写一段Lua脚本\r\n\r\n    if redis.call(\"get\",KEY[1]) == ARGV[1]\r\n    then\r\n        return redis.call(\"del\",KEY[1])\r\n    else\r\n        return 0\r\n    end\r\n只有当对应的值与当前线程设的值一样时，当前线程才可以释放掉锁。redis内置的lua脚本解释器也保证了\r\n每段脚本执行的原子性，不必担心有其他意外发生。\r\n\r\n这些看起来很美好，但是不幸的是，依旧存在问题。如果我们的redis是master-slave架构，某个时刻master挂了，\r\n由于master和slave之间是异步的，如果新选出来的master没有这条锁的记录，那么其他线程便能够获取到该锁。那么\r\n有没有什么办法可以解决这个问题呢，答案是有的，大名鼎鼎的redlock就是为此诞生的。由于精力有限，redlock的讨论\r\n就过段时间再说，这里先挖个坑。\r\n"}]},{"category":"技巧","payload":[{"title":"编程相关小技巧","date":"2022-04-29","tags":["技巧"],"categories":"技巧","content":"\r\n目前内容较少，没有分篇叙述的必要，预计达到100个`tip`开分\r\n\r\n1. 在vscode中编写markdown文档时自动换行\r\n> - ctrl + shift + p,打开命令窗口，输入setting，打开open user settings\r\n> - 在搜索栏中搜索markdown\r\n> - 将Markdown>Preview：Breaks打上勾就ok了\r\n"}]}];
export const tagsAll = ["spring","non-blocking","I/O","reactive","functional","programming","essay","Java","byte","code","编程风格","lambda","纯函数","leetcode","redis","分布式锁","技巧","消息队列","中间件","rabbitmq"];
export const tagsMap = [{"tag":"spring","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"tag":"non-blocking","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"tag":"I/O","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"tag":"reactive","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"},{"title":"reactive programming","date":"2022-05-11","tags":["reactive","编程风格"],"categories":"theory","content":"\r\n\r\n"}]},{"tag":"functional","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"tag":"programming","payload":[{"title":"what is spring webflux","date":"2022-05-11","tags":["spring","non-blocking","I/O","reactive","functional","programming"],"categories":"Java","content":"\r\n\r\nspring5中加入了基于reactive的web框架-spring webflux，其支持完全意义上的non-blocking，可运行在netty，undertow以及Servlet3.1+的容器中。使用webflux而不是webmvc，我们可以在非阻塞式I/O的网络模型下愉快地进行函数式编程，\r\n"}]},{"tag":"essay","payload":[{"title":"观‘技术人不要看中文’有感","date":"2022-04-29","tags":["essay"],"categories":"随笔","content":"\r\n\r\n今日B站给推送一个视频，标题叫‘[50岁程序员：技术人不准看中文！](https://www.bilibili.com/video/BV1Sr4y1J7K9?spm_id_from=333.999.0.0)’ 。短短25秒大致意思就是中文互联网下所获取学习到的相关技术已经比其原本所具备的能力打了折扣。评论最高赞的三个评论我贴在下方。![反对方论点](../resources/img/journal_review1.png)  ![支持方论点](../resources/img/journal_review2.png)\r\n\r\n就我个人来说，技术人不准看中文大致上是准确。诚然，中文互联网上是可以找到大量优质的技术文章，它们或者短小精悍，或者详尽有趣，看完也能大有收获。但是呢，这里有一个问题，我怎么才能找到这些文章呢？对于一个小白来说代价有点大。遇到问题，借助百度，搜到的答案要么同质化程度太高，要么水平低下，要么早已过时。(google好一些，但或多或少还是会遇到这种情况，怎么解决还有待探索)。一些技术论坛，rss的情况好一些，可以时不时的找到一些高质量文章，有时在评论区也能有所收获，但也都是随缘，毕竟这些生产高质量文章的大佬一是更新日期不固定，二是实时的关注点也会有所差异。当然我们也可以去看书，这里有两类，一类是由英文翻译而来的技术书，一类是中文作者原创的技术书。中文原创的技术书一般都是实战型，就着某个框架，某门技术给你现造个应用出来，这么做其实好的，编程这个东西就得实践，看一百本书都比不上做一个完整项目的收获大。但是这么做也是有问题的，一本几百页的书并且是在以项目为基础的前提下所能包含的相关技术的内涵是有限的，而且这些书一般也会绑定某个版本做项目，当我们要换个版本做应用，并且版本的变化相对较大时，我们还是得去看官方的文档，这些文档鲜少会提供中文。至于由英文翻译而来的技术书呢，则良莠不齐，有些甚至都可以看出是机翻。\r\n\r\n所以对于反对者所说的看英文文档效率低的问题我是不认同的，相对与在中文互联网中四处闲逛还是收获甚小所造成的开销，翻译层的开销是可以忽略的。至于后半段真假参半的话术，还扯上脊梁问题，那就令人反感了。这里为什么说真假参半呢，因为这里是有指导意义的，读应当读英文，那些大佬有空也可以做一些优秀的中文输出反馈到中文社区，从而形成中文互联网的良性循环。虽然在这个流量变现，而不是付费变现的时代，期待这成为现实有些困难，但万一呢 :wink: "}]},{"tag":"Java","payload":[{"title":"字节码-无关性的基石","date":"2022-05-04","tags":["Java","byte","code"],"categories":"Java","content":"\r\n\r\n字节码技术是虚拟机实现平台无关性，语言无关性的基石，得益于此，Java语言才能在嵌入式，web服务端等领域大展拳脚并受到长期欢迎。围绕字节码技术，发展出一批拥有不同特性的运行于Java虚拟机之上的编程语言，如groovy，Scala，kotlin等。虚拟机只与class文件绑定，它不关心class文件来自何处，是来自本地的磁盘文件，还是来自于网络，是由.java文件编译而来，还是由.groovy文件编译而来，只要是有效的class文件，虚拟机便能够运行。\r\n\r\n一个class文件由连续的8-bit、16-bit和32-bit的无符号数的流构成，并且以大端模式存储。class文件的格式可以以一种C-like结构体的方式描述，结构体由`items`和`tables`构成。tables由零个或者任意的items构成。class文件的格式结构体描述如下，其中u1，u2，u4为`items`,_info结尾的项为`tables`\r\n\r\n    ClassFile{\r\n        u4              magic;\r\n        u2              minor_version;\r\n        u2              major_version;\r\n        u2              constant_pool_count;\r\n        cp_info         constant_pool[constant_pool_count-1];\r\n        u2              access_flags;\r\n        u2              this_class;\r\n        u2              super_class;\r\n        u2              interfaces_count;\r\n        u2              interfaces[interfaces_count];\r\n        u2              fields_count;\r\n        field_info      fields[fields_count];\r\n        u2              methods_count;\r\n        method_info     methods[methods_count];\r\n        u2              attributes_count;\r\n        attribute_info  attributes[attributes_count];\r\n    }\r\n\r\n> magic\r\n\r\n魔数，固定为OxCAFEBABE,标志为一个class文件。\r\n\r\n> minor_version,major_version\r\n\r\n它们共同决定了一个class文件的版本，不同的Java SE所能支持的class文件版本是不同的，比如Java8支持主版本45-52，Java18支持主版本45-62。主版本号 >= 56时，此版本号限制为0或者65535，之前的主版本则随意。Java虚拟机的实现如果遵循JavaSE的某版本(>=12)，那么就必须支持该版本的preview feature，并且默认关闭支持，但是提供途径可以开启支持。一个class文件的版本若为(45 - N+44).65535的形式，则其是依赖JavaSEN的preview feature的class文件。一个遵循JavaSEN的虚拟机实现，只有在开启preview feature支持时，才能加载(45 - N+44).65535的class文件，普通的则不受影响。\r\n\r\n> constant_pool_count\r\n\r\n常量池条目的数量加一。\r\n\r\n> constant_pool[]\r\n\r\n常量池是一张可包含各种字符串常量，类名，接口名，字段名以及其他表示class文件中条目的常量的表，表中entry的格式由其第一个字节`tag`指示。常量表的索引从1到constant_pool_count - 1。\r\n\r\n> access_flags\r\n\r\naccess_flags是一个掩码标记，用来指示一个类或者接口的访问权限以及各种属性。\r\n\r\n|Flag name|Value|Interpretation|\r\n|:-|:-:|:-|\r\n|ACC_PUBLIC|0x0001|Declared public; may be accessed from outside its package.|\r\n|ACC_FINAL|0x0010|Declared final; no subclasses allowed|\r\n|ACC_SUPER|0x0020|Treat superclass methods specially when invoked by the invokespecial instruction|\r\n|ACC_INTERFACE|0x0200|Is an interface, not a class|\r\n|ACC_ABSTRACT|0x0400|Declared abstract; must not be instantiated|\r\n|ACC_SYNTHETIC|0x1000|Declared synthetic; not present in the source code.|\r\n|ACC_ANNATATION|0x2000|Declared as an annotation interface.|\r\n|ACC_ENUM|0x4000|Declared as an enum class.|\r\n|ACC_MODULE|0x8000|Is a module, not a class or interface.|\r\n\r\nACC_SUPER用来指示当遇到invokespecial指令将表示的两种语义时，应该选择哪种进行解释。Java8之后，无论class文件是否设置该值，虚拟机都认为设置了。ACC_SYNTHETIC指示该类或者接口是由编译器动态生成的，而不是本身就存在于源码中的。\r\n\r\n> this_class\r\n\r\n该值是常量池表的一个有效索引，索引指向的条目必须是一个代表该类或者接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> super_class\r\n\r\n该值或为0或为指向常量池的一个有效索引，若为0，则超类为Object，否则指向常量池中一个代表超类结构的`CONSTANT_Class_info`类型。\r\n\r\n> interfaces_count\r\n\r\n代表该类或者接口有几个直接父接口。\r\n\r\n> interfaces[]\r\n\r\n一个指向常量池的有效索引的数组，每个索引指向的条目必须是代表父接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> fields_count\r\n\r\n指示该类或接口的类变量和实例变量的总数目。\r\n\r\n> fields[]\r\n\r\n字段表的每个条目必须是`field_info`结构，用来表示一个字段的完整描述。\r\n\r\n> methods_count\r\n\r\n指示该类或者接口有多少方法。\r\n\r\n> methods[]\r\n\r\n方法表的每个条目必须是`method_info`结构，用来表示一个方法的完整描述。如果结构中没有设置`ACC_NATIVE`或者`ACC_ABSTRACT`，那么方法的虚拟机指令实现也会被提供。\r\n\r\n> attributes_count\r\n\r\n指示该类属性的总数目。\r\n\r\n> attributes[]\r\n\r\n属性表的每个条目必须是`attribute_info`结构，用来表示一个属性的完整描述。属性表条目可以用来表示class文件的属性，也可以用来表示一个方法的属性。`attribute_info`的结构如下：\r\n\r\n    attribute_info {\r\n        u2 attribute_name_index; \r\n        u4 attribute_length; \r\n        u1 info[attribute_length];\r\n    }\r\n\r\n常量池表是class文件的资源仓库，与class文件中的其他item有着各种各样的联系。常量池表的第0号索引被空出来，用来在表示不引用任何常量池item的特殊含义。常量池中主要有两类常量：字面量和符号引用，字面量接近Java语言层面的常量概念，符号引用则属于编译原理方面的概念，主要包括package、Fully Qualified Name、Descriptor、Method Handle、Method Type、Invoke Dynamic、Dynamically-Computed Call Site、Dynamically-Computed Constant。\r\n\r\n类或者接口的名称在class文件中总是被表示为全限定类名的utf8编码形式，放在常量池的`CONSTANT_Utf8_info`结构中。而方法，字段，本地变量，形参则为非全限定类名的Unicode编码方式。\r\n\r\n类中的字段和方法的类型被一个叫descriptor的字符串来表示，其在常量池中是一个`CONSTANT_Utf8_info`结构。字段描述符被表示为FieldDescriptor:FieldType。Object类型的字段的描述符为Ljava/lang/Object,double[][][]类型的字段的描述符为[[[D，array类型不能超过255个维度。方法描述符被表示为：MethodDescriptor:( {ParameterDescriptor} ) ReturnDescriptor，比如Object m(int i, double d, Thread t) {...}的描述符为(IDLjava/lang/Thread;)Ljava/lang/Object;。\r\n\r\n常量池的每一项都是一个表，截至jdk18，共有17类表结构，这些表结构的第一项都是一个u1的tag，表示其是哪种类型的表结构。具体如下所示：\r\n|Constant Kind|Tag|\r\n|:-|:-|\r\n|CONSTANT_Class|7|\r\n|CONSTANT_Fieldref|9|\r\n|CONSTANT_Methodref|10|\r\n|CONSTANT_InterfaceMethodref|11|\r\n|CONSTANT_String|8|\r\n|CONSTANT_Integer|3|\r\n|CONSTANT_Float|4|\r\n|CONSTANT_Long|5|\r\n|CONSTANT_Double|6|\r\n|CONSTANT_NameAndType|12|\r\n|CONSTANT_Utf8|1|\r\n|CONSTANT_MethodHandle|15|\r\n|CONSTANT_MethodType|16|\r\n|CONSTANT_Dynamic|17|\r\n|CONSTANT_InvokeDynamic|18|\r\n|CONSTANT_Module|19|\r\n|CONSTANT_Package|20|\r\n\r\n所有类型的条目都遵循以下格式：\r\n\r\n    cp_info { \r\n        u1 tag;\r\n        u1 info[]; \r\n    }\r\n\r\n- CONSTANT_Class_info\r\n\r\n        CONSTANT_Class_info {\r\n            // 7  \r\n            u1 tag;\r\n\r\n            // 指向常量池表的某一项，该项为CONSTANT_Utf8_info结构\r\n            // 存储类的全限定类名\r\n            u2 name_index;  \r\n        }\r\n\r\n- CONSTANT_Fieldref_info\r\n\r\n        CONSTANT_Fieldref_info { \r\n            // 9\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构可表示一个类或者接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和字段描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_Methodref_info\r\n\r\n        CONSTANT_Methodref_info { \r\n            // 10\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个类\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_InterfaceMethodref_info\r\n\r\n        CONSTANT_InterfaceMethodref_info { \r\n            // 11\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_String_info\r\n\r\n        CONSTANT_String_info { \r\n            // 8\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info结构\r\n            // 该结构表示字符串对象的Unicode编码\r\n            u2 string_index; \r\n        }\r\n\r\n- CONSTANT_Integer_info\r\n\r\n        CONSTANT_Integer_info {\r\n            // 3 \r\n            u1 tag; \r\n\r\n            // 表示int值\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Float_info\r\n\r\n        CONSTANT_Float_info { \r\n            // 4 \r\n            u1 tag; \r\n\r\n            // 表示为IEEE754的单浮点数编码\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Long_info\r\n  \r\n        CONSTANT_Long_info { \r\n            // 5\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_Double_info\r\n  \r\n        CONSTANT_Double_info { \r\n            // 6\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_NameAndType_info\r\n\r\n        CONSTANT_NameAndType_info { \r\n            // 12\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法的名称\r\n            u2 name_index; \r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法描述符\r\n            u2 descriptor_index;\r\n        }\r\n\r\n- CONSTANT_Utf8_info\r\n\r\n        CONSTANT_Utf8_info { \r\n            // 1\r\n            u1 tag;\r\n\r\n            // byte数组的长度\r\n            u2 length; \r\n\r\n            // UTF-8编码\r\n            u1 bytes[length]; \r\n        }\r\n\r\n- CONSTANT_MethodHandle_info\r\n\r\n        CONSTANT_MethodHandle_info { \r\n            // 15\r\n            u1 tag;\r\n\r\n            // 表示方法句柄的类型，该类型会影响字节码的行为\r\n            // 1.REF_getField 2.REF_getStatic 3.REF_putField\r\n            // 4.REF_putStatic 5.REF_invokeVirtual 6.REF_invokeStatic\r\n            // 7.REF_invokeSpecial 8.REF_newInvokeSpecial 9.REF_invokeInterface\r\n            u1 reference_kind; \r\n\r\n            // 根据reference_kind的值，指向常量池中的某CONSTANT_Fieldref_info\r\n\r\n            // CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info结构\r\n            u2 reference_index;\r\n        }\r\n\r\n- CONSTANT_MethodType_info\r\n\r\n        CONSTANT_MethodType_info { \r\n            // 16\r\n            u1 tag;\r\n\r\n            // 指向常量池中的某表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n        }\r\n\r\n- CONSTANT_Dynamic_info （表示一个动态调用计算出的常量）\r\n\r\n        CONSTANT_Dynamic_info { \r\n            // 17\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示字段描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_InvokeDynamic_info （表示一个动态计算出的方法调用）\r\n  \r\n        CONSTANT_InvokeDynamic_info { \r\n            // 18\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示方法描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_Module_info\r\n\r\n        CONSTANT_Module_info { \r\n            // 19\r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示模块名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n\r\n- CONSTANT_Package_info\r\n\r\n        CONSTANT_Package_info {\r\n            // 20 \r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示包名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n    \r\nclass文件中fields数组中的条目都遵循`field_info`结构，数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n    field_info {\r\n        // 掩码标记，指示访问权限以及属性\r\n        // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED\r\n        // ACC_STATIC、ACC_FINAL、ACC_VOLATILE\r\n        // ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM\r\n        u2 access_flags; \r\n\r\n        // 指向常量池中一个表示字段名的CONSTANT_Utf8_info结构\r\n        u2 name_index;\r\n\r\n        // 指向常量池中一个表示字段描述符的CONSTANT_Utf8_info结构\r\n        u2 descriptor_index; \r\n\r\n        // 字段额外属性数组的大小\r\n        u2 attributes_count;\r\n\r\n        // attribute_info结构的数组\r\n        attribute_info attributes[attributes_count]; \r\n    }\r\n\r\nclass文件中methods数组中的条目都遵循`method_info`结构，每个条目表示一个方法，一个实例初始化方法，或者一个类初始化方法。数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n        method_info { \r\n            // 掩码标记，指示访问权限以及属性\r\n            // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC\r\n            // ACC_FINAL、ACC_SYNCHRONIZED、ACC_BRIDGE、ACC_VARARGS\r\n            // ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT、ACC_SYNTHETIC\r\n            u2 access_flags; \r\n\r\n            // 指向常量池中一个表示方法，<init>方法或者<clinit>方法的CONSTANT_Utf8_info结构\r\n            u2 name_index;\r\n\r\n            // 指向常量池中一个表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n\r\n            // 方法额外属性数组的大小\r\n            attributes_count;\r\n\r\n            // attribute_info结构的数组\r\n            attribute_info attributes[attributes_count]; \r\n        }\r\n\r\nattributes被用在class文件，field_info，method_info，Code_attribute，record_component_info结构中。field_info结构如下：\r\n\r\n        attribute_info {\r\n            // 指向常量池中一个表示属性名的CONSTANT_Utf8_info结构\r\n            u2 attribute_name_index; \r\n\r\n            // 表示附加属性的字节长度\r\n            u4 attribute_length;\r\n\r\n            // 附加属性\r\n            u1 info[attribute_length];\r\n        }\r\n\r\n附加属性相关的东西就说来话长了，有时间在写吧。"}]},{"tag":"byte","payload":[{"title":"字节码-无关性的基石","date":"2022-05-04","tags":["Java","byte","code"],"categories":"Java","content":"\r\n\r\n字节码技术是虚拟机实现平台无关性，语言无关性的基石，得益于此，Java语言才能在嵌入式，web服务端等领域大展拳脚并受到长期欢迎。围绕字节码技术，发展出一批拥有不同特性的运行于Java虚拟机之上的编程语言，如groovy，Scala，kotlin等。虚拟机只与class文件绑定，它不关心class文件来自何处，是来自本地的磁盘文件，还是来自于网络，是由.java文件编译而来，还是由.groovy文件编译而来，只要是有效的class文件，虚拟机便能够运行。\r\n\r\n一个class文件由连续的8-bit、16-bit和32-bit的无符号数的流构成，并且以大端模式存储。class文件的格式可以以一种C-like结构体的方式描述，结构体由`items`和`tables`构成。tables由零个或者任意的items构成。class文件的格式结构体描述如下，其中u1，u2，u4为`items`,_info结尾的项为`tables`\r\n\r\n    ClassFile{\r\n        u4              magic;\r\n        u2              minor_version;\r\n        u2              major_version;\r\n        u2              constant_pool_count;\r\n        cp_info         constant_pool[constant_pool_count-1];\r\n        u2              access_flags;\r\n        u2              this_class;\r\n        u2              super_class;\r\n        u2              interfaces_count;\r\n        u2              interfaces[interfaces_count];\r\n        u2              fields_count;\r\n        field_info      fields[fields_count];\r\n        u2              methods_count;\r\n        method_info     methods[methods_count];\r\n        u2              attributes_count;\r\n        attribute_info  attributes[attributes_count];\r\n    }\r\n\r\n> magic\r\n\r\n魔数，固定为OxCAFEBABE,标志为一个class文件。\r\n\r\n> minor_version,major_version\r\n\r\n它们共同决定了一个class文件的版本，不同的Java SE所能支持的class文件版本是不同的，比如Java8支持主版本45-52，Java18支持主版本45-62。主版本号 >= 56时，此版本号限制为0或者65535，之前的主版本则随意。Java虚拟机的实现如果遵循JavaSE的某版本(>=12)，那么就必须支持该版本的preview feature，并且默认关闭支持，但是提供途径可以开启支持。一个class文件的版本若为(45 - N+44).65535的形式，则其是依赖JavaSEN的preview feature的class文件。一个遵循JavaSEN的虚拟机实现，只有在开启preview feature支持时，才能加载(45 - N+44).65535的class文件，普通的则不受影响。\r\n\r\n> constant_pool_count\r\n\r\n常量池条目的数量加一。\r\n\r\n> constant_pool[]\r\n\r\n常量池是一张可包含各种字符串常量，类名，接口名，字段名以及其他表示class文件中条目的常量的表，表中entry的格式由其第一个字节`tag`指示。常量表的索引从1到constant_pool_count - 1。\r\n\r\n> access_flags\r\n\r\naccess_flags是一个掩码标记，用来指示一个类或者接口的访问权限以及各种属性。\r\n\r\n|Flag name|Value|Interpretation|\r\n|:-|:-:|:-|\r\n|ACC_PUBLIC|0x0001|Declared public; may be accessed from outside its package.|\r\n|ACC_FINAL|0x0010|Declared final; no subclasses allowed|\r\n|ACC_SUPER|0x0020|Treat superclass methods specially when invoked by the invokespecial instruction|\r\n|ACC_INTERFACE|0x0200|Is an interface, not a class|\r\n|ACC_ABSTRACT|0x0400|Declared abstract; must not be instantiated|\r\n|ACC_SYNTHETIC|0x1000|Declared synthetic; not present in the source code.|\r\n|ACC_ANNATATION|0x2000|Declared as an annotation interface.|\r\n|ACC_ENUM|0x4000|Declared as an enum class.|\r\n|ACC_MODULE|0x8000|Is a module, not a class or interface.|\r\n\r\nACC_SUPER用来指示当遇到invokespecial指令将表示的两种语义时，应该选择哪种进行解释。Java8之后，无论class文件是否设置该值，虚拟机都认为设置了。ACC_SYNTHETIC指示该类或者接口是由编译器动态生成的，而不是本身就存在于源码中的。\r\n\r\n> this_class\r\n\r\n该值是常量池表的一个有效索引，索引指向的条目必须是一个代表该类或者接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> super_class\r\n\r\n该值或为0或为指向常量池的一个有效索引，若为0，则超类为Object，否则指向常量池中一个代表超类结构的`CONSTANT_Class_info`类型。\r\n\r\n> interfaces_count\r\n\r\n代表该类或者接口有几个直接父接口。\r\n\r\n> interfaces[]\r\n\r\n一个指向常量池的有效索引的数组，每个索引指向的条目必须是代表父接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> fields_count\r\n\r\n指示该类或接口的类变量和实例变量的总数目。\r\n\r\n> fields[]\r\n\r\n字段表的每个条目必须是`field_info`结构，用来表示一个字段的完整描述。\r\n\r\n> methods_count\r\n\r\n指示该类或者接口有多少方法。\r\n\r\n> methods[]\r\n\r\n方法表的每个条目必须是`method_info`结构，用来表示一个方法的完整描述。如果结构中没有设置`ACC_NATIVE`或者`ACC_ABSTRACT`，那么方法的虚拟机指令实现也会被提供。\r\n\r\n> attributes_count\r\n\r\n指示该类属性的总数目。\r\n\r\n> attributes[]\r\n\r\n属性表的每个条目必须是`attribute_info`结构，用来表示一个属性的完整描述。属性表条目可以用来表示class文件的属性，也可以用来表示一个方法的属性。`attribute_info`的结构如下：\r\n\r\n    attribute_info {\r\n        u2 attribute_name_index; \r\n        u4 attribute_length; \r\n        u1 info[attribute_length];\r\n    }\r\n\r\n常量池表是class文件的资源仓库，与class文件中的其他item有着各种各样的联系。常量池表的第0号索引被空出来，用来在表示不引用任何常量池item的特殊含义。常量池中主要有两类常量：字面量和符号引用，字面量接近Java语言层面的常量概念，符号引用则属于编译原理方面的概念，主要包括package、Fully Qualified Name、Descriptor、Method Handle、Method Type、Invoke Dynamic、Dynamically-Computed Call Site、Dynamically-Computed Constant。\r\n\r\n类或者接口的名称在class文件中总是被表示为全限定类名的utf8编码形式，放在常量池的`CONSTANT_Utf8_info`结构中。而方法，字段，本地变量，形参则为非全限定类名的Unicode编码方式。\r\n\r\n类中的字段和方法的类型被一个叫descriptor的字符串来表示，其在常量池中是一个`CONSTANT_Utf8_info`结构。字段描述符被表示为FieldDescriptor:FieldType。Object类型的字段的描述符为Ljava/lang/Object,double[][][]类型的字段的描述符为[[[D，array类型不能超过255个维度。方法描述符被表示为：MethodDescriptor:( {ParameterDescriptor} ) ReturnDescriptor，比如Object m(int i, double d, Thread t) {...}的描述符为(IDLjava/lang/Thread;)Ljava/lang/Object;。\r\n\r\n常量池的每一项都是一个表，截至jdk18，共有17类表结构，这些表结构的第一项都是一个u1的tag，表示其是哪种类型的表结构。具体如下所示：\r\n|Constant Kind|Tag|\r\n|:-|:-|\r\n|CONSTANT_Class|7|\r\n|CONSTANT_Fieldref|9|\r\n|CONSTANT_Methodref|10|\r\n|CONSTANT_InterfaceMethodref|11|\r\n|CONSTANT_String|8|\r\n|CONSTANT_Integer|3|\r\n|CONSTANT_Float|4|\r\n|CONSTANT_Long|5|\r\n|CONSTANT_Double|6|\r\n|CONSTANT_NameAndType|12|\r\n|CONSTANT_Utf8|1|\r\n|CONSTANT_MethodHandle|15|\r\n|CONSTANT_MethodType|16|\r\n|CONSTANT_Dynamic|17|\r\n|CONSTANT_InvokeDynamic|18|\r\n|CONSTANT_Module|19|\r\n|CONSTANT_Package|20|\r\n\r\n所有类型的条目都遵循以下格式：\r\n\r\n    cp_info { \r\n        u1 tag;\r\n        u1 info[]; \r\n    }\r\n\r\n- CONSTANT_Class_info\r\n\r\n        CONSTANT_Class_info {\r\n            // 7  \r\n            u1 tag;\r\n\r\n            // 指向常量池表的某一项，该项为CONSTANT_Utf8_info结构\r\n            // 存储类的全限定类名\r\n            u2 name_index;  \r\n        }\r\n\r\n- CONSTANT_Fieldref_info\r\n\r\n        CONSTANT_Fieldref_info { \r\n            // 9\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构可表示一个类或者接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和字段描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_Methodref_info\r\n\r\n        CONSTANT_Methodref_info { \r\n            // 10\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个类\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_InterfaceMethodref_info\r\n\r\n        CONSTANT_InterfaceMethodref_info { \r\n            // 11\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_String_info\r\n\r\n        CONSTANT_String_info { \r\n            // 8\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info结构\r\n            // 该结构表示字符串对象的Unicode编码\r\n            u2 string_index; \r\n        }\r\n\r\n- CONSTANT_Integer_info\r\n\r\n        CONSTANT_Integer_info {\r\n            // 3 \r\n            u1 tag; \r\n\r\n            // 表示int值\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Float_info\r\n\r\n        CONSTANT_Float_info { \r\n            // 4 \r\n            u1 tag; \r\n\r\n            // 表示为IEEE754的单浮点数编码\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Long_info\r\n  \r\n        CONSTANT_Long_info { \r\n            // 5\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_Double_info\r\n  \r\n        CONSTANT_Double_info { \r\n            // 6\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_NameAndType_info\r\n\r\n        CONSTANT_NameAndType_info { \r\n            // 12\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法的名称\r\n            u2 name_index; \r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法描述符\r\n            u2 descriptor_index;\r\n        }\r\n\r\n- CONSTANT_Utf8_info\r\n\r\n        CONSTANT_Utf8_info { \r\n            // 1\r\n            u1 tag;\r\n\r\n            // byte数组的长度\r\n            u2 length; \r\n\r\n            // UTF-8编码\r\n            u1 bytes[length]; \r\n        }\r\n\r\n- CONSTANT_MethodHandle_info\r\n\r\n        CONSTANT_MethodHandle_info { \r\n            // 15\r\n            u1 tag;\r\n\r\n            // 表示方法句柄的类型，该类型会影响字节码的行为\r\n            // 1.REF_getField 2.REF_getStatic 3.REF_putField\r\n            // 4.REF_putStatic 5.REF_invokeVirtual 6.REF_invokeStatic\r\n            // 7.REF_invokeSpecial 8.REF_newInvokeSpecial 9.REF_invokeInterface\r\n            u1 reference_kind; \r\n\r\n            // 根据reference_kind的值，指向常量池中的某CONSTANT_Fieldref_info\r\n\r\n            // CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info结构\r\n            u2 reference_index;\r\n        }\r\n\r\n- CONSTANT_MethodType_info\r\n\r\n        CONSTANT_MethodType_info { \r\n            // 16\r\n            u1 tag;\r\n\r\n            // 指向常量池中的某表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n        }\r\n\r\n- CONSTANT_Dynamic_info （表示一个动态调用计算出的常量）\r\n\r\n        CONSTANT_Dynamic_info { \r\n            // 17\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示字段描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_InvokeDynamic_info （表示一个动态计算出的方法调用）\r\n  \r\n        CONSTANT_InvokeDynamic_info { \r\n            // 18\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示方法描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_Module_info\r\n\r\n        CONSTANT_Module_info { \r\n            // 19\r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示模块名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n\r\n- CONSTANT_Package_info\r\n\r\n        CONSTANT_Package_info {\r\n            // 20 \r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示包名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n    \r\nclass文件中fields数组中的条目都遵循`field_info`结构，数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n    field_info {\r\n        // 掩码标记，指示访问权限以及属性\r\n        // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED\r\n        // ACC_STATIC、ACC_FINAL、ACC_VOLATILE\r\n        // ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM\r\n        u2 access_flags; \r\n\r\n        // 指向常量池中一个表示字段名的CONSTANT_Utf8_info结构\r\n        u2 name_index;\r\n\r\n        // 指向常量池中一个表示字段描述符的CONSTANT_Utf8_info结构\r\n        u2 descriptor_index; \r\n\r\n        // 字段额外属性数组的大小\r\n        u2 attributes_count;\r\n\r\n        // attribute_info结构的数组\r\n        attribute_info attributes[attributes_count]; \r\n    }\r\n\r\nclass文件中methods数组中的条目都遵循`method_info`结构，每个条目表示一个方法，一个实例初始化方法，或者一个类初始化方法。数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n        method_info { \r\n            // 掩码标记，指示访问权限以及属性\r\n            // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC\r\n            // ACC_FINAL、ACC_SYNCHRONIZED、ACC_BRIDGE、ACC_VARARGS\r\n            // ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT、ACC_SYNTHETIC\r\n            u2 access_flags; \r\n\r\n            // 指向常量池中一个表示方法，<init>方法或者<clinit>方法的CONSTANT_Utf8_info结构\r\n            u2 name_index;\r\n\r\n            // 指向常量池中一个表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n\r\n            // 方法额外属性数组的大小\r\n            attributes_count;\r\n\r\n            // attribute_info结构的数组\r\n            attribute_info attributes[attributes_count]; \r\n        }\r\n\r\nattributes被用在class文件，field_info，method_info，Code_attribute，record_component_info结构中。field_info结构如下：\r\n\r\n        attribute_info {\r\n            // 指向常量池中一个表示属性名的CONSTANT_Utf8_info结构\r\n            u2 attribute_name_index; \r\n\r\n            // 表示附加属性的字节长度\r\n            u4 attribute_length;\r\n\r\n            // 附加属性\r\n            u1 info[attribute_length];\r\n        }\r\n\r\n附加属性相关的东西就说来话长了，有时间在写吧。"}]},{"tag":"code","payload":[{"title":"字节码-无关性的基石","date":"2022-05-04","tags":["Java","byte","code"],"categories":"Java","content":"\r\n\r\n字节码技术是虚拟机实现平台无关性，语言无关性的基石，得益于此，Java语言才能在嵌入式，web服务端等领域大展拳脚并受到长期欢迎。围绕字节码技术，发展出一批拥有不同特性的运行于Java虚拟机之上的编程语言，如groovy，Scala，kotlin等。虚拟机只与class文件绑定，它不关心class文件来自何处，是来自本地的磁盘文件，还是来自于网络，是由.java文件编译而来，还是由.groovy文件编译而来，只要是有效的class文件，虚拟机便能够运行。\r\n\r\n一个class文件由连续的8-bit、16-bit和32-bit的无符号数的流构成，并且以大端模式存储。class文件的格式可以以一种C-like结构体的方式描述，结构体由`items`和`tables`构成。tables由零个或者任意的items构成。class文件的格式结构体描述如下，其中u1，u2，u4为`items`,_info结尾的项为`tables`\r\n\r\n    ClassFile{\r\n        u4              magic;\r\n        u2              minor_version;\r\n        u2              major_version;\r\n        u2              constant_pool_count;\r\n        cp_info         constant_pool[constant_pool_count-1];\r\n        u2              access_flags;\r\n        u2              this_class;\r\n        u2              super_class;\r\n        u2              interfaces_count;\r\n        u2              interfaces[interfaces_count];\r\n        u2              fields_count;\r\n        field_info      fields[fields_count];\r\n        u2              methods_count;\r\n        method_info     methods[methods_count];\r\n        u2              attributes_count;\r\n        attribute_info  attributes[attributes_count];\r\n    }\r\n\r\n> magic\r\n\r\n魔数，固定为OxCAFEBABE,标志为一个class文件。\r\n\r\n> minor_version,major_version\r\n\r\n它们共同决定了一个class文件的版本，不同的Java SE所能支持的class文件版本是不同的，比如Java8支持主版本45-52，Java18支持主版本45-62。主版本号 >= 56时，此版本号限制为0或者65535，之前的主版本则随意。Java虚拟机的实现如果遵循JavaSE的某版本(>=12)，那么就必须支持该版本的preview feature，并且默认关闭支持，但是提供途径可以开启支持。一个class文件的版本若为(45 - N+44).65535的形式，则其是依赖JavaSEN的preview feature的class文件。一个遵循JavaSEN的虚拟机实现，只有在开启preview feature支持时，才能加载(45 - N+44).65535的class文件，普通的则不受影响。\r\n\r\n> constant_pool_count\r\n\r\n常量池条目的数量加一。\r\n\r\n> constant_pool[]\r\n\r\n常量池是一张可包含各种字符串常量，类名，接口名，字段名以及其他表示class文件中条目的常量的表，表中entry的格式由其第一个字节`tag`指示。常量表的索引从1到constant_pool_count - 1。\r\n\r\n> access_flags\r\n\r\naccess_flags是一个掩码标记，用来指示一个类或者接口的访问权限以及各种属性。\r\n\r\n|Flag name|Value|Interpretation|\r\n|:-|:-:|:-|\r\n|ACC_PUBLIC|0x0001|Declared public; may be accessed from outside its package.|\r\n|ACC_FINAL|0x0010|Declared final; no subclasses allowed|\r\n|ACC_SUPER|0x0020|Treat superclass methods specially when invoked by the invokespecial instruction|\r\n|ACC_INTERFACE|0x0200|Is an interface, not a class|\r\n|ACC_ABSTRACT|0x0400|Declared abstract; must not be instantiated|\r\n|ACC_SYNTHETIC|0x1000|Declared synthetic; not present in the source code.|\r\n|ACC_ANNATATION|0x2000|Declared as an annotation interface.|\r\n|ACC_ENUM|0x4000|Declared as an enum class.|\r\n|ACC_MODULE|0x8000|Is a module, not a class or interface.|\r\n\r\nACC_SUPER用来指示当遇到invokespecial指令将表示的两种语义时，应该选择哪种进行解释。Java8之后，无论class文件是否设置该值，虚拟机都认为设置了。ACC_SYNTHETIC指示该类或者接口是由编译器动态生成的，而不是本身就存在于源码中的。\r\n\r\n> this_class\r\n\r\n该值是常量池表的一个有效索引，索引指向的条目必须是一个代表该类或者接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> super_class\r\n\r\n该值或为0或为指向常量池的一个有效索引，若为0，则超类为Object，否则指向常量池中一个代表超类结构的`CONSTANT_Class_info`类型。\r\n\r\n> interfaces_count\r\n\r\n代表该类或者接口有几个直接父接口。\r\n\r\n> interfaces[]\r\n\r\n一个指向常量池的有效索引的数组，每个索引指向的条目必须是代表父接口结构的`CONSTANT_Class_info`类型。\r\n\r\n> fields_count\r\n\r\n指示该类或接口的类变量和实例变量的总数目。\r\n\r\n> fields[]\r\n\r\n字段表的每个条目必须是`field_info`结构，用来表示一个字段的完整描述。\r\n\r\n> methods_count\r\n\r\n指示该类或者接口有多少方法。\r\n\r\n> methods[]\r\n\r\n方法表的每个条目必须是`method_info`结构，用来表示一个方法的完整描述。如果结构中没有设置`ACC_NATIVE`或者`ACC_ABSTRACT`，那么方法的虚拟机指令实现也会被提供。\r\n\r\n> attributes_count\r\n\r\n指示该类属性的总数目。\r\n\r\n> attributes[]\r\n\r\n属性表的每个条目必须是`attribute_info`结构，用来表示一个属性的完整描述。属性表条目可以用来表示class文件的属性，也可以用来表示一个方法的属性。`attribute_info`的结构如下：\r\n\r\n    attribute_info {\r\n        u2 attribute_name_index; \r\n        u4 attribute_length; \r\n        u1 info[attribute_length];\r\n    }\r\n\r\n常量池表是class文件的资源仓库，与class文件中的其他item有着各种各样的联系。常量池表的第0号索引被空出来，用来在表示不引用任何常量池item的特殊含义。常量池中主要有两类常量：字面量和符号引用，字面量接近Java语言层面的常量概念，符号引用则属于编译原理方面的概念，主要包括package、Fully Qualified Name、Descriptor、Method Handle、Method Type、Invoke Dynamic、Dynamically-Computed Call Site、Dynamically-Computed Constant。\r\n\r\n类或者接口的名称在class文件中总是被表示为全限定类名的utf8编码形式，放在常量池的`CONSTANT_Utf8_info`结构中。而方法，字段，本地变量，形参则为非全限定类名的Unicode编码方式。\r\n\r\n类中的字段和方法的类型被一个叫descriptor的字符串来表示，其在常量池中是一个`CONSTANT_Utf8_info`结构。字段描述符被表示为FieldDescriptor:FieldType。Object类型的字段的描述符为Ljava/lang/Object,double[][][]类型的字段的描述符为[[[D，array类型不能超过255个维度。方法描述符被表示为：MethodDescriptor:( {ParameterDescriptor} ) ReturnDescriptor，比如Object m(int i, double d, Thread t) {...}的描述符为(IDLjava/lang/Thread;)Ljava/lang/Object;。\r\n\r\n常量池的每一项都是一个表，截至jdk18，共有17类表结构，这些表结构的第一项都是一个u1的tag，表示其是哪种类型的表结构。具体如下所示：\r\n|Constant Kind|Tag|\r\n|:-|:-|\r\n|CONSTANT_Class|7|\r\n|CONSTANT_Fieldref|9|\r\n|CONSTANT_Methodref|10|\r\n|CONSTANT_InterfaceMethodref|11|\r\n|CONSTANT_String|8|\r\n|CONSTANT_Integer|3|\r\n|CONSTANT_Float|4|\r\n|CONSTANT_Long|5|\r\n|CONSTANT_Double|6|\r\n|CONSTANT_NameAndType|12|\r\n|CONSTANT_Utf8|1|\r\n|CONSTANT_MethodHandle|15|\r\n|CONSTANT_MethodType|16|\r\n|CONSTANT_Dynamic|17|\r\n|CONSTANT_InvokeDynamic|18|\r\n|CONSTANT_Module|19|\r\n|CONSTANT_Package|20|\r\n\r\n所有类型的条目都遵循以下格式：\r\n\r\n    cp_info { \r\n        u1 tag;\r\n        u1 info[]; \r\n    }\r\n\r\n- CONSTANT_Class_info\r\n\r\n        CONSTANT_Class_info {\r\n            // 7  \r\n            u1 tag;\r\n\r\n            // 指向常量池表的某一项，该项为CONSTANT_Utf8_info结构\r\n            // 存储类的全限定类名\r\n            u2 name_index;  \r\n        }\r\n\r\n- CONSTANT_Fieldref_info\r\n\r\n        CONSTANT_Fieldref_info { \r\n            // 9\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构可表示一个类或者接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和字段描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_Methodref_info\r\n\r\n        CONSTANT_Methodref_info { \r\n            // 10\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个类\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_InterfaceMethodref_info\r\n\r\n        CONSTANT_InterfaceMethodref_info { \r\n            // 11\r\n            u1 tag;\r\n\r\n            // 指向常量池的某CONSTANT_Class_info结构\r\n            // 该结构只能表示一个接口\r\n            u2 class_index; \r\n\r\n            // 指向常量池的某CONSTANT_NameAndType_info结构\r\n            // 指示名称和方法描述符\r\n            u2 name_and_type_index; \r\n        }\r\n\r\n- CONSTANT_String_info\r\n\r\n        CONSTANT_String_info { \r\n            // 8\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info结构\r\n            // 该结构表示字符串对象的Unicode编码\r\n            u2 string_index; \r\n        }\r\n\r\n- CONSTANT_Integer_info\r\n\r\n        CONSTANT_Integer_info {\r\n            // 3 \r\n            u1 tag; \r\n\r\n            // 表示int值\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Float_info\r\n\r\n        CONSTANT_Float_info { \r\n            // 4 \r\n            u1 tag; \r\n\r\n            // 表示为IEEE754的单浮点数编码\r\n            u4 bytes;\r\n        }\r\n\r\n- CONSTANT_Long_info\r\n  \r\n        CONSTANT_Long_info { \r\n            // 5\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_Double_info\r\n  \r\n        CONSTANT_Double_info { \r\n            // 6\r\n            u1 tag;\r\n\r\n            // 高位\r\n            u4 high_bytes;\r\n\r\n            // 低位 \r\n            u4 low_bytes;\r\n        }\r\n\r\n- CONSTANT_NameAndType_info\r\n\r\n        CONSTANT_NameAndType_info { \r\n            // 12\r\n            u1 tag;\r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法的名称\r\n            u2 name_index; \r\n\r\n            // 指向常量池的一个CONSTANT_Utf8_info\r\n            // 表示一个字段或者方法描述符\r\n            u2 descriptor_index;\r\n        }\r\n\r\n- CONSTANT_Utf8_info\r\n\r\n        CONSTANT_Utf8_info { \r\n            // 1\r\n            u1 tag;\r\n\r\n            // byte数组的长度\r\n            u2 length; \r\n\r\n            // UTF-8编码\r\n            u1 bytes[length]; \r\n        }\r\n\r\n- CONSTANT_MethodHandle_info\r\n\r\n        CONSTANT_MethodHandle_info { \r\n            // 15\r\n            u1 tag;\r\n\r\n            // 表示方法句柄的类型，该类型会影响字节码的行为\r\n            // 1.REF_getField 2.REF_getStatic 3.REF_putField\r\n            // 4.REF_putStatic 5.REF_invokeVirtual 6.REF_invokeStatic\r\n            // 7.REF_invokeSpecial 8.REF_newInvokeSpecial 9.REF_invokeInterface\r\n            u1 reference_kind; \r\n\r\n            // 根据reference_kind的值，指向常量池中的某CONSTANT_Fieldref_info\r\n\r\n            // CONSTANT_Methodref_info或者CONSTANT_InterfaceMethodref_info结构\r\n            u2 reference_index;\r\n        }\r\n\r\n- CONSTANT_MethodType_info\r\n\r\n        CONSTANT_MethodType_info { \r\n            // 16\r\n            u1 tag;\r\n\r\n            // 指向常量池中的某表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n        }\r\n\r\n- CONSTANT_Dynamic_info （表示一个动态调用计算出的常量）\r\n\r\n        CONSTANT_Dynamic_info { \r\n            // 17\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示字段描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_InvokeDynamic_info （表示一个动态计算出的方法调用）\r\n  \r\n        CONSTANT_InvokeDynamic_info { \r\n            // 18\r\n            u1 tag;\r\n\r\n            // 指向attribute数组中bootstrap_methods数组的有效索引值\r\n            u2 bootstrap_method_attr_index; \r\n\r\n            // 指向常量池中的一个表示方法描述符的CONSTANT_NameAndType_info结构\r\n            u2 name_and_type_index;\r\n        }\r\n\r\n- CONSTANT_Module_info\r\n\r\n        CONSTANT_Module_info { \r\n            // 19\r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示模块名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n\r\n- CONSTANT_Package_info\r\n\r\n        CONSTANT_Package_info {\r\n            // 20 \r\n            u1 tag;\r\n\r\n            // 指向常量池中一个表示包名的CONSTANT_Utf8_info结构\r\n            u2 name_index; \r\n        }\r\n    \r\nclass文件中fields数组中的条目都遵循`field_info`结构，数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n    field_info {\r\n        // 掩码标记，指示访问权限以及属性\r\n        // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED\r\n        // ACC_STATIC、ACC_FINAL、ACC_VOLATILE\r\n        // ACC_TRANSIENT、ACC_SYNTHETIC、ACC_ENUM\r\n        u2 access_flags; \r\n\r\n        // 指向常量池中一个表示字段名的CONSTANT_Utf8_info结构\r\n        u2 name_index;\r\n\r\n        // 指向常量池中一个表示字段描述符的CONSTANT_Utf8_info结构\r\n        u2 descriptor_index; \r\n\r\n        // 字段额外属性数组的大小\r\n        u2 attributes_count;\r\n\r\n        // attribute_info结构的数组\r\n        attribute_info attributes[attributes_count]; \r\n    }\r\n\r\nclass文件中methods数组中的条目都遵循`method_info`结构，每个条目表示一个方法，一个实例初始化方法，或者一个类初始化方法。数组中的任意两个条目都不可能有相同的名称和描述符。field_info结构如下：\r\n\r\n        method_info { \r\n            // 掩码标记，指示访问权限以及属性\r\n            // ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED、ACC_STATIC\r\n            // ACC_FINAL、ACC_SYNCHRONIZED、ACC_BRIDGE、ACC_VARARGS\r\n            // ACC_NATIVE、ACC_ABSTRACT、ACC_STRICT、ACC_SYNTHETIC\r\n            u2 access_flags; \r\n\r\n            // 指向常量池中一个表示方法，<init>方法或者<clinit>方法的CONSTANT_Utf8_info结构\r\n            u2 name_index;\r\n\r\n            // 指向常量池中一个表示方法描述符的CONSTANT_Utf8_info结构\r\n            u2 descriptor_index; \r\n\r\n            // 方法额外属性数组的大小\r\n            attributes_count;\r\n\r\n            // attribute_info结构的数组\r\n            attribute_info attributes[attributes_count]; \r\n        }\r\n\r\nattributes被用在class文件，field_info，method_info，Code_attribute，record_component_info结构中。field_info结构如下：\r\n\r\n        attribute_info {\r\n            // 指向常量池中一个表示属性名的CONSTANT_Utf8_info结构\r\n            u2 attribute_name_index; \r\n\r\n            // 表示附加属性的字节长度\r\n            u4 attribute_length;\r\n\r\n            // 附加属性\r\n            u1 info[attribute_length];\r\n        }\r\n\r\n附加属性相关的东西就说来话长了，有时间在写吧。"}]},{"tag":"编程风格","payload":[{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"],"categories":"theory","content":"\r\n\r\n> 函数式编程是一种编程范式，区别于面向对象编程和面向过程编程的命令风格，其风格是声明式的，是满足若干要素的构建软件的方式。\r\n\r\n函数式编程由纯函数的组合构成，以避免共享状态、可变数据以及副作用。理解函数式编程的第一步就是要理解什么是纯函数。\r\n\r\n所谓纯函数就是那种对于给定输入总是得出固定输出且不产生任何副作用的函数。纯函数是函数的一种类型，一个函数的目的可以是值映射，一系列步骤的组合或者是同系统中的其他模块通信。纯函数总是和值映射相关，一个参数，一个固定输出。比如Math.max(11,13)无论被调用多少次，什么时候调用，其结果都是13。而且因为该函数不存在将值存盘或者输出到标准输出上的行为，理论上来说，只要Math.max(11,13)出现的地方，都可以用13去代替。即所谓的引用透明性(referential transparency)。Math.random(),System.currentTime()不是纯函数，因为它们不满足一个输入对应一个输出的原则。\r\n\r\n纯函数用副本实现不可变性的。区别于全拷贝，它将数据分成一个个很小的块，只对变化的块进行复制，很象git管理库和提交的方式。基于不可变性，纯函数也不会修改任何外部状态。\r\n\r\n纯函数不修改外部状态避免了共享状态，也意味着不会产生任何副作用。在共享状态下，并发/并行过程 + 可变状态 = 不确定性，一个不确定的系统结果是无法预测的，可能会产生各种奇奇怪怪的bug，纯函数可以帮助我们避免这种bug。\r\n\r\n函数组合就是将两个以上的函数以某种顺序组合成一个函数的过程，一个函数就像是一个管道，我们的数据就在这一系列的管道中流过。基于这种风格，我们可以减少中间变量的使用。\r\n\r\n函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象的编程倾向于将方法和数据放在对象中。那些并置的方法只能对它们设计用于操作的数据类型进行操作，并且通常只能对包含在该特定对象实例中的数据进行操作。在函数式编程中，任何类型的数据都是平等的。相同的 map()实用程序可以映射对象、字符串、数字或任何其他数据类型，因为它将函数作为参数来适当地处理给定的数据类型。函数式编程使用高阶函数实现了它的通用实用技巧。\r\n\r\n更加具体清晰的functional programming说明可以参考Eric Elliott的文章[Master the JavaScript Interview: What is Functional Programming?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0),以及Russ Olsen的演讲[Functional Programming in 40 Minutes](https://www.youtube.com/watch?v=0if71HOyVjY)。\r\n"},{"title":"reactive programming","date":"2022-05-11","tags":["reactive","编程风格"],"categories":"theory","content":"\r\n\r\n"}]},{"tag":"lambda","payload":[{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"],"categories":"theory","content":"\r\n\r\n> 函数式编程是一种编程范式，区别于面向对象编程和面向过程编程的命令风格，其风格是声明式的，是满足若干要素的构建软件的方式。\r\n\r\n函数式编程由纯函数的组合构成，以避免共享状态、可变数据以及副作用。理解函数式编程的第一步就是要理解什么是纯函数。\r\n\r\n所谓纯函数就是那种对于给定输入总是得出固定输出且不产生任何副作用的函数。纯函数是函数的一种类型，一个函数的目的可以是值映射，一系列步骤的组合或者是同系统中的其他模块通信。纯函数总是和值映射相关，一个参数，一个固定输出。比如Math.max(11,13)无论被调用多少次，什么时候调用，其结果都是13。而且因为该函数不存在将值存盘或者输出到标准输出上的行为，理论上来说，只要Math.max(11,13)出现的地方，都可以用13去代替。即所谓的引用透明性(referential transparency)。Math.random(),System.currentTime()不是纯函数，因为它们不满足一个输入对应一个输出的原则。\r\n\r\n纯函数用副本实现不可变性的。区别于全拷贝，它将数据分成一个个很小的块，只对变化的块进行复制，很象git管理库和提交的方式。基于不可变性，纯函数也不会修改任何外部状态。\r\n\r\n纯函数不修改外部状态避免了共享状态，也意味着不会产生任何副作用。在共享状态下，并发/并行过程 + 可变状态 = 不确定性，一个不确定的系统结果是无法预测的，可能会产生各种奇奇怪怪的bug，纯函数可以帮助我们避免这种bug。\r\n\r\n函数组合就是将两个以上的函数以某种顺序组合成一个函数的过程，一个函数就像是一个管道，我们的数据就在这一系列的管道中流过。基于这种风格，我们可以减少中间变量的使用。\r\n\r\n函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象的编程倾向于将方法和数据放在对象中。那些并置的方法只能对它们设计用于操作的数据类型进行操作，并且通常只能对包含在该特定对象实例中的数据进行操作。在函数式编程中，任何类型的数据都是平等的。相同的 map()实用程序可以映射对象、字符串、数字或任何其他数据类型，因为它将函数作为参数来适当地处理给定的数据类型。函数式编程使用高阶函数实现了它的通用实用技巧。\r\n\r\n更加具体清晰的functional programming说明可以参考Eric Elliott的文章[Master the JavaScript Interview: What is Functional Programming?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0),以及Russ Olsen的演讲[Functional Programming in 40 Minutes](https://www.youtube.com/watch?v=0if71HOyVjY)。\r\n"}]},{"tag":"纯函数","payload":[{"title":"functional programming","date":"2022-05-05","tags":["编程风格","lambda","纯函数"],"categories":"theory","content":"\r\n\r\n> 函数式编程是一种编程范式，区别于面向对象编程和面向过程编程的命令风格，其风格是声明式的，是满足若干要素的构建软件的方式。\r\n\r\n函数式编程由纯函数的组合构成，以避免共享状态、可变数据以及副作用。理解函数式编程的第一步就是要理解什么是纯函数。\r\n\r\n所谓纯函数就是那种对于给定输入总是得出固定输出且不产生任何副作用的函数。纯函数是函数的一种类型，一个函数的目的可以是值映射，一系列步骤的组合或者是同系统中的其他模块通信。纯函数总是和值映射相关，一个参数，一个固定输出。比如Math.max(11,13)无论被调用多少次，什么时候调用，其结果都是13。而且因为该函数不存在将值存盘或者输出到标准输出上的行为，理论上来说，只要Math.max(11,13)出现的地方，都可以用13去代替。即所谓的引用透明性(referential transparency)。Math.random(),System.currentTime()不是纯函数，因为它们不满足一个输入对应一个输出的原则。\r\n\r\n纯函数用副本实现不可变性的。区别于全拷贝，它将数据分成一个个很小的块，只对变化的块进行复制，很象git管理库和提交的方式。基于不可变性，纯函数也不会修改任何外部状态。\r\n\r\n纯函数不修改外部状态避免了共享状态，也意味着不会产生任何副作用。在共享状态下，并发/并行过程 + 可变状态 = 不确定性，一个不确定的系统结果是无法预测的，可能会产生各种奇奇怪怪的bug，纯函数可以帮助我们避免这种bug。\r\n\r\n函数组合就是将两个以上的函数以某种顺序组合成一个函数的过程，一个函数就像是一个管道，我们的数据就在这一系列的管道中流过。基于这种风格，我们可以减少中间变量的使用。\r\n\r\n函数式编程倾向于重用一组通用的函数式实用程序来处理数据。面向对象的编程倾向于将方法和数据放在对象中。那些并置的方法只能对它们设计用于操作的数据类型进行操作，并且通常只能对包含在该特定对象实例中的数据进行操作。在函数式编程中，任何类型的数据都是平等的。相同的 map()实用程序可以映射对象、字符串、数字或任何其他数据类型，因为它将函数作为参数来适当地处理给定的数据类型。函数式编程使用高阶函数实现了它的通用实用技巧。\r\n\r\n更加具体清晰的functional programming说明可以参考Eric Elliott的文章[Master the JavaScript Interview: What is Functional Programming?](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0),以及Russ Olsen的演讲[Functional Programming in 40 Minutes](https://www.youtube.com/watch?v=0if71HOyVjY)。\r\n"}]},{"tag":"leetcode","payload":[{"title":"123.买卖股票的最佳时机Ⅲ","date":"2022-05-03","tags":["leetcode"],"categories":"leetcode","content":"\r\n\r\n> 题目描述\r\n\r\n给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成两笔交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\r\n\r\n> 例1\r\n\r\n    输入：prices = [3,3,5,0,0,3,1,4]\r\n    输出：6\r\n    解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。\r\n    随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候 卖出，这笔交易所能获得利润 = 4-1 = 3 。\r\n> 例2\r\n\r\n    输入：prices = [1,2,3,4,5]\r\n    输出：4\r\n    解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   \r\n    注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出.因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\r\n> 例3\r\n\r\n    输入：prices = [7,6,4,3,1] \r\n    输出：0 \r\n    解释：在这个情况下, 没有交易完成, 所以最大利润为 0。\r\n\r\n思路：我们可做的交易数为0，1，2，也就是说最多可以做两笔交易。那么我们可以以第i天为界，计算出[0 - i]最大收益数和[i - n]最大收益数之和，得到的结果就是我们想要的答案。<div align=\"center\"><img src=\"../resources/img/leetcode_123_1.jpg\"></div>\r\n\r\n附上代码\r\n\r\n    //123.买卖股票的最佳时机 III\r\n    public int maxProfit(int[] prices) {\r\n        int ans = 0;\r\n        int len = prices.length;\r\n        //前i + 1天所能得到的最大收益\r\n        int[] beforeProfits = new int[len];\r\n        int min = prices[0],max = prices[0];\r\n        for (int i = 1; i < len; i++) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            beforeProfits[i] = Math.max(beforeProfits[i - 1],prices[i] - min);\r\n        }\r\n        min = prices[len - 1];\r\n        max = prices[len - 1];\r\n        //后n - i天所能得到的最大收益\r\n        int[] afterProfits = new int[len];\r\n        for (int i = len - 2; i >= 0; i--) {\r\n            min = Math.min(min,prices[i]);\r\n            max = Math.max(max,prices[i]);\r\n            afterProfits[i] = Math.max(afterProfits[i + 1],max - prices[i]);\r\n        }\r\n        for (int i = 0; i < len; i++) {\r\n            ans = Math.max(ans,beforeProfits[i] + afterProfits[i]);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n"},{"title":"42.接雨水","date":"2022-05-03","tags":["leetcode"],"categories":"leetcode","content":"\r\n\r\n> 题目描述\r\n\r\n给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\r\n\r\n> 例1\r\n\r\n    输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\r\n    输出：6\r\n\r\n> 例2\r\n\r\n    输入：height = [4,2,0,3,2,5]\r\n    输出：9\r\n\r\n> 思路\r\n\r\n- 首先找出所有的制高点，所谓制高点就是广义极大值点\r\n- （关键）以每个制高点为左边界，找到其右边界。具体做法是沿着制高点数组向右找第一个大于等于的制高点作为右边界，如果找到头也没找到，则把其中最大的作为右边界\r\n- 从最左制高点开始将其作为左边界，将上一步找到的其右边界作为右边界，找到它们当中的较低点作为水平面值，从此点开始向左或者向右将深度加到结果中去，直到遇到某处的高度大于水平面值为止。之后将右边界作为左边界循环此步，直到边界抵达最右制高点。\r\n\r\n> 附上代码\r\n\r\n    public int trap(int[] height) {\r\n        int ans = 0;\r\n        int len = height.length;\r\n        if(len == 1){\r\n            return ans;\r\n        }\r\n        //制高点list\r\n        List<Integer> list = new ArrayList<>();\r\n        //将所有制高点的数组下标按顺序放入list中\r\n        if(height[0] >= height[1]){\r\n            list.add(0);\r\n        }\r\n        for (int i = 1; i < len - 1; i++) {\r\n            if(height[i] >= height[i - 1] && height[i] >= height[i + 1]){\r\n                list.add(i);\r\n            }\r\n        }\r\n        if(height[len - 1] >= height[len - 2]){\r\n            list.add(len - 1);\r\n        }\r\n        int size = list.size();\r\n        //所有制高点的右边界的list下标\r\n        int[] rightFirstHigher = new int[size];\r\n        rightFirstHigher[size - 1] = size;\r\n        //关键步骤，从右向左找到所有制高点的右边界的list下标\r\n        for (int i = size - 2; i >= 0; i--) {\r\n            //next期望找到第一个大于等于当前制高点的下标，nextI为未找到next前小于当前制高点的最高点的下标\r\n            int h = height[list.get(i)],next = i + 1,nextI = i + 1;\r\n            while (next < size && height[list.get(next)] < h){\r\n                if(height[list.get(next)] > height[list.get(nextI)]){\r\n                    nextI = next;\r\n                }\r\n                next = rightFirstHigher[next];\r\n            }\r\n            //没找到，右边界为nextI，否则为next\r\n            rightFirstHigher[i] = next == size ? nextI : next;\r\n        }\r\n        //统计各区间的水量\r\n        for (int i = 0; i < size - 1; i=rightFirstHigher[i]) {\r\n            int left = list.get(i),right = list.get(rightFirstHigher[i]);\r\n            int min = Math.min(height[left],height[right]);\r\n            if(height[left] < height[right]){\r\n                for (int j = left + 1; j < right; j++) {\r\n                    //保证不大于水平面高度\r\n                    if(height[j] > min){\r\n                        break;\r\n                    }\r\n                    ans += min - height[j];\r\n                }\r\n            }else {\r\n                for (int j = right - 1; j > left; j--) {\r\n                    if(height[j] > min){\r\n                        break;\r\n                    }\r\n                    ans += min - height[j];\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n时空间复杂度感人:joy:\r\n"}]},{"tag":"redis","payload":[{"title":"使用redis实现分布式锁","date":"2022-04-29","tags":["redis","分布式锁"],"categories":"中间件","content":"\r\n\r\n## 使用redis实现分布式锁\r\n\r\n>同一操作系统下的线程竞态访问某一临界资源，我们可以使用锁来帮助我们达成目的，一些编程语言\r\n都会提供内置的锁库。但是当我们的执行线程并不运行在同一操作系统之下，单一实例下的锁机制就\r\n失效了，这种情况下，我们需要分布式锁机制来帮助我们协调管理线程之间的竞争。\r\n\r\n我们可以在redis的帮助下实现分布式锁机制。只需要一条简单的命令我们便能做到它。\r\n\r\n    set resource_name unique_value NX;\r\n在我们进入临界区之前，先尝试着向redis中插入一条数据，若该数据存在则获取锁失败，否则获取\r\n锁成功。不过这里有一个问题，就是若获取锁的线程在释放锁之前挂了，那么锁就无法被释放，其他线程\r\n也就没有办法获取到锁。为了解决这个问题，我们可以将unique_value设置为`expire_timestamp`，\r\n另外的线程可以get到`expire_timestamp`，若该时间戳小于当前时间戳，我们便可以执行del命令进而\r\n释放到锁，再执行获取锁的指令，就ok了。然而虽解决了锁无法释放的问题，却引入了新的问题。这里\r\n我们假设有两个线程在同一时刻检测到了锁失效，然后相继执行释放锁加锁的步骤，像下面这样：\r\n\r\n    Thread 1:del resource_name;\r\n    Thread 1:set resource_name unique_value NX;\r\n    Thread 2:del resource_name;\r\n    Thread 2:set resource_name unique_value NX;\r\n最终Thread1和Thead2都获得了锁，违反了分布式锁的含义。因此相应的，我们不应该将释放锁的权力\r\n交给其他线程。释放锁的工作应当由获取锁的线程去做，若该线程挂了，那么该锁应当超时自动释放，redis\r\n同样提供了这样的机制，将上面的改一改：\r\n\r\n    set resource_name unique_value NX EX expire_time;\r\n即使获取锁的线程挂了，该锁也能够在超时之后释放掉。但是呢，这个命令还是有问题。假设这把锁被超时释放了，\r\n另外的线程又获取到了这把锁，然而之前获取锁的线程并没有挂掉，它只是执行的比较慢而已，在另一个线程获取锁\r\n之后它才执行释放锁的操作，然后它就把其他线程的锁给释放掉了。显然这是不符合逻辑的，上面就提到没有把持锁\r\n的线程没有释放锁的权力，那么这个时候unique_value就起到了作用，当我们获取锁的时候将键对应的值设为\r\n全局唯一的某个值，比如timestamp + clientId，然后我们可以写一段Lua脚本\r\n\r\n    if redis.call(\"get\",KEY[1]) == ARGV[1]\r\n    then\r\n        return redis.call(\"del\",KEY[1])\r\n    else\r\n        return 0\r\n    end\r\n只有当对应的值与当前线程设的值一样时，当前线程才可以释放掉锁。redis内置的lua脚本解释器也保证了\r\n每段脚本执行的原子性，不必担心有其他意外发生。\r\n\r\n这些看起来很美好，但是不幸的是，依旧存在问题。如果我们的redis是master-slave架构，某个时刻master挂了，\r\n由于master和slave之间是异步的，如果新选出来的master没有这条锁的记录，那么其他线程便能够获取到该锁。那么\r\n有没有什么办法可以解决这个问题呢，答案是有的，大名鼎鼎的redlock就是为此诞生的。由于精力有限，redlock的讨论\r\n就过段时间再说，这里先挖个坑。\r\n"}]},{"tag":"分布式锁","payload":[{"title":"使用redis实现分布式锁","date":"2022-04-29","tags":["redis","分布式锁"],"categories":"中间件","content":"\r\n\r\n## 使用redis实现分布式锁\r\n\r\n>同一操作系统下的线程竞态访问某一临界资源，我们可以使用锁来帮助我们达成目的，一些编程语言\r\n都会提供内置的锁库。但是当我们的执行线程并不运行在同一操作系统之下，单一实例下的锁机制就\r\n失效了，这种情况下，我们需要分布式锁机制来帮助我们协调管理线程之间的竞争。\r\n\r\n我们可以在redis的帮助下实现分布式锁机制。只需要一条简单的命令我们便能做到它。\r\n\r\n    set resource_name unique_value NX;\r\n在我们进入临界区之前，先尝试着向redis中插入一条数据，若该数据存在则获取锁失败，否则获取\r\n锁成功。不过这里有一个问题，就是若获取锁的线程在释放锁之前挂了，那么锁就无法被释放，其他线程\r\n也就没有办法获取到锁。为了解决这个问题，我们可以将unique_value设置为`expire_timestamp`，\r\n另外的线程可以get到`expire_timestamp`，若该时间戳小于当前时间戳，我们便可以执行del命令进而\r\n释放到锁，再执行获取锁的指令，就ok了。然而虽解决了锁无法释放的问题，却引入了新的问题。这里\r\n我们假设有两个线程在同一时刻检测到了锁失效，然后相继执行释放锁加锁的步骤，像下面这样：\r\n\r\n    Thread 1:del resource_name;\r\n    Thread 1:set resource_name unique_value NX;\r\n    Thread 2:del resource_name;\r\n    Thread 2:set resource_name unique_value NX;\r\n最终Thread1和Thead2都获得了锁，违反了分布式锁的含义。因此相应的，我们不应该将释放锁的权力\r\n交给其他线程。释放锁的工作应当由获取锁的线程去做，若该线程挂了，那么该锁应当超时自动释放，redis\r\n同样提供了这样的机制，将上面的改一改：\r\n\r\n    set resource_name unique_value NX EX expire_time;\r\n即使获取锁的线程挂了，该锁也能够在超时之后释放掉。但是呢，这个命令还是有问题。假设这把锁被超时释放了，\r\n另外的线程又获取到了这把锁，然而之前获取锁的线程并没有挂掉，它只是执行的比较慢而已，在另一个线程获取锁\r\n之后它才执行释放锁的操作，然后它就把其他线程的锁给释放掉了。显然这是不符合逻辑的，上面就提到没有把持锁\r\n的线程没有释放锁的权力，那么这个时候unique_value就起到了作用，当我们获取锁的时候将键对应的值设为\r\n全局唯一的某个值，比如timestamp + clientId，然后我们可以写一段Lua脚本\r\n\r\n    if redis.call(\"get\",KEY[1]) == ARGV[1]\r\n    then\r\n        return redis.call(\"del\",KEY[1])\r\n    else\r\n        return 0\r\n    end\r\n只有当对应的值与当前线程设的值一样时，当前线程才可以释放掉锁。redis内置的lua脚本解释器也保证了\r\n每段脚本执行的原子性，不必担心有其他意外发生。\r\n\r\n这些看起来很美好，但是不幸的是，依旧存在问题。如果我们的redis是master-slave架构，某个时刻master挂了，\r\n由于master和slave之间是异步的，如果新选出来的master没有这条锁的记录，那么其他线程便能够获取到该锁。那么\r\n有没有什么办法可以解决这个问题呢，答案是有的，大名鼎鼎的redlock就是为此诞生的。由于精力有限，redlock的讨论\r\n就过段时间再说，这里先挖个坑。\r\n"}]},{"tag":"技巧","payload":[{"title":"编程相关小技巧","date":"2022-04-29","tags":["技巧"],"categories":"技巧","content":"\r\n目前内容较少，没有分篇叙述的必要，预计达到100个`tip`开分\r\n\r\n1. 在vscode中编写markdown文档时自动换行\r\n> - ctrl + shift + p,打开命令窗口，输入setting，打开open user settings\r\n> - 在搜索栏中搜索markdown\r\n> - 将Markdown>Preview：Breaks打上勾就ok了\r\n"}]},{"tag":"消息队列","payload":[{"title":"rabbitmq与AMQP","date":"2022-05-01","tags":["消息队列","中间件","rabbitmq"],"categories":"中间件","content":"\r\n\r\nrabbitmq是一款被广泛使用的消息队列中间件，它目前被Pivotal公司所拥有。其基于`AMQM`、`AMQP`并用`erlang`语言实现，拥有诸多特性，譬如开源、强大商业支持、跨语言、跨平台、轻量级、扩展性强、可定制、安全支持等。它可以通过分布式部署满足高可用的需求，其吞吐量亦十分可观，能够达到万/s的级别，当然吞吐量的高的代价是比较吃cpu，我们可以根据自身系统在可用性和性能两方面做权衡。另外rabbitmq还支持异地多活和异地多活多主架构。\r\nrabbitmq强悍的力量很大程度上是因为其基于`AMQP`，`AMQP`不仅定义了网络层协议而且对服务端的服务和行为也做了定义，即`AMQ model`。`AMQ model`就消息路由行为定义了三个抽象组件：`Exchange,Queue,Binding`。\r\n- Exchange：将消息路由给队列的组件\r\n- Queue：存在于内存或者磁盘中的存储消息的数据结构\r\n- Binding：Exchange将消息分发给Queue的规则\r\n\r\n将一个message发送到broker后，broker的行为如下图所示：<div align=\"center\"><img src=\"../../resources/img/rabbitmq-message-send.jpg\"></div>\r\n\r\n实际使用时，每种Exchange类型处理routing-key的行为会有所差异，有的不做任何处理，有些则需要进行复杂的模式匹配提取，header exchange甚至根本就不管routing-key是啥。rabbitmq在设计中扩展了AMQ model，exchange不仅接受queue的绑定，而且接受其他exchange的绑定，这种特性为消息的路由模式提供了相当的灵活性。\r\n\r\nrabbitmq客户端库的实现都会隐藏掉基于AMQP进行通信的复杂性，这或许对用户来说是一件好事，用户的绝大多数精力可以用在应用层上，不必关心实际上的复杂性。但我们还是应当熟悉AMQP协议，只有这样，我们才不会在应用性能没有达到预期或者是出现错误时束手无策。\r\n\r\nrabbitmq利用`RPC`模式实现AMQP的通信，但是具体实现又同一般的RPC模式有所不同。一般来说，进行RPC通信的双方，客户端发送指令给服务端，服务端处理后返回响应，这里服务端是不会发指令给客户端的，但是rabbitmq的RPC实现中，服务端会。<div align=\"center\"><img src=\"../../resources/img/rabbitmq-conversation.jpg\" height=600px></div>\r\n\r\nrabbitmq客户端与服务端之间建立通信首先需要经过三次握手。首先客户端会发送包含Protocol Header的Greeting给服务端，接着服务端发送Connection.Start给客户端，最后客户端发送Connection.StartOk给服务端，之后一个连接就建立了。在客户端与服务端之间进行有实际意义的交流之前，还得在连接中打开channel，在channel中进行AMQP帧的传输。channel是双工的，并且可以在一个连接中有多个，有点像HTTP2。\r\n\r\nAMQP的命令由类和方法组成，像Connection.Start中，Connection是对象，Start是方法。当命令被发送到客户端或者服务端时，执行命令所需的参数被封装到帧中进行传输。底层的AMQP帧大致上长这样。<div align=\"center\"><img src=\"../../resources/img/amqp-frame.jpg\" ></div>\r\n\r\n帧的头部由帧类型，channe编码，payload大小组成。有五种帧的类型如下所示：\r\n- protocol header frame：只会在在连接到rabbitmq时用到\r\n- method frame：携带RPC请求或者响应\r\n- content header frame：包含消息的大小和属性\r\n- body frame：消息内容\r\n- heartbeat frame：心跳检测确认通信双方存活\r\n\r\n在channel中的数据总是以`method frame`，`content header frame`，多个`body frame`的顺序流动。method frame被特殊编码以压缩大小，典型的method frame头两个字段包含类型和方法，之后的一个字段是exchange name，再然后是routing-key，最后可能会有一个mandatory字段以让rabbitmq在没有满足消息发布需求时给客户端进行反馈。content header frame的payload主体由Basic.Properties表组成，通过它可以很方便的实现消息的定制化。content header frame也会被特殊编码。body frame则不会被特殊编码，它可以装载各种格式的图片，json/xml格式数据或者是文档等。\r\n\r\n在AMQ model中，`exchange`和`queue`都是一等公民。创建一个exchange对应的method是Exchange.Declare,如果创建成功，rabbitmq会返回Exchange.DeclareOk,否则会返回Channel.Close。类似的，创建一个queue对应的method是Queue.Declare,如果创建成功，rabbitmq会返回Queue.DeclareOk,否则会返回Channel.Close。将一个queue绑定到exchange的method是Queue.Bind,绑定成功，rabbitmq会返回Queue.BindOk。以上的method在AMQP中都是同步命令，在AMQP中也有一些命令通过异步的方式来接受和发送消息。\r\n\r\n当我们通过Basic.Publish发布消息到rabbitmq中时，可以将消息存储到内存或者是磁盘中去，并且只会储存一份，丢到队列中的实际是实例的一份引用，不同队列的实例引用之间互不影响。当我们把消息丢到队列中去之后，剩下的就是消费了，客户端发送Basic.Consume请求消费，然后rabbitmq响应Basic.ConsumeOk表示可以开始消费，若客户端想要终止消费过程，可以发送Basic.Cancel,这是一个异步命令，所以客户端此时还是会收到rabbitmq发来的消息。\r\n\r\n受限于精力，能力和时间成本，rabbitmq的AMQP实现的了解暂时先到此为止。如果想进一步了解，可以参考[rabbitmq的官方文档](https://www.rabbitmq.com/protocol.html)。\r\n\r\n附上Basic.Properties的属性表：<div align=\"center\"><img src=\"../../resources/img/Basic-properties.png\"></div>\r\n"},{"title":"rabbitmq中的队列和exchange","date":"2022-05-02","tags":["rabbitmq","中间件","消息队列"],"categories":"中间件","content":"\r\n\r\n队列毫无疑问在消息队列中占据着核心地位，rabbitmq提供了诸多设置让我们能够自如地定义队列。这些设置有很多，挑一些常用的列举在下方：\r\n- 自动删除\r\n- 限制唯一消费者消费\r\n- 自动过期队列\r\n- 限制消息的数量\r\n\r\n非常重要的是，一旦我们创建了一个队列，队列的设置就无法被更改了，改变队列的设置只能通过删除然后重新创建的方式。\r\n\r\n通过在`Queue.Declare`请求中加入`auto_delete`标志可以创建临时队列，所谓临时队列就是一旦消费者拿走队列的全部消息、断开连接，队列就会被删除。值得留意的是，临时队列可以被任意数量的消费者消费，只有当不再有消费者监听该队列了，这个队列才会被删除。\r\n\r\n在队列声明请求中加入`exclusive`标志可以限制消费者的数量为一，声明一个排他队列，排他队列也会自动删除，但它的行为和临时队列有所不同，排他队列在连接断开后被删除，临时队列则与是否有订阅者有关。\r\n\r\n通过在队列声明请求中加入`x-expires`参数可以声明一个定时队列，参数单位为毫秒，定时队列会在过期时间到后被自动删除，需要注意的是只要定时队列上由消费者，那么除非消费者停止订阅或者连接断开，该队列是不会被自动删除的。另外当消费者向该队列发送`Basic.Get`请求后，`x-expires`参数就失效了，该队列不再是定时队列了。rabbitmq不保证删除定时队列的及时性。\r\n\r\n通过在创建队列请求中将`durable`参数置为true，可以让该队列成为一个永久队列，并被持久化到磁盘中去，直到`Queue.Delete`命令删除该队列。\r\n\r\n通过在创建队列时设置`x-message-ttl`可以设置队列中消息的过期时间，设置`x-max-length`可以设置队列最大消息数，当队列中的消息达到了这个数目，就无法向队列中添加消息了。如果该队列声明了`DLX`，那么过期的消息和无法添加的消息会被交给`DLX`处理。\r\n\r\n声明一个队列可使用的参数及其作用如下图所示：<div align=\"center\"><img src=\"../../resources/img/queue-argument.png\"></div>\r\n\r\nrabbitmq最强大的力量来自于exchange基于消息中的routing信息将消息路由至不同队列的灵活性。通过exchange，消息可以被路由至一个或多个队列，其他exchange，还可以是外部资源。在rabbitmq中有四种类型的exchange：\r\n- Direct exchange\r\n- Fanout exchange\r\n- Topic exchange\r\n- Headers exchange\r\n\r\nDirect exchange是rabbitmq中最简单的exchange，它可以被多个队列绑定，当消息发送至此exchange时，它会将消息的routing-key同与之绑定的队列的binding-key做比较，只有当两个字符串完全相等时，exchange才会将消息丢到队列中去。\r\n\r\nFanout exchange会将接受的消息发送到所有绑定的队列中去，因为不需要进行routing-key和binding-key的比较，所有性能会很好，但是也因为缺乏选择机制，路由至所有队列中的消息都应该被消费。\r\n\r\nTopic exchange同Direct exchange一样会基于routing-key选择性的路由消息到队列中，不同的是Topic exchange不需要完全匹配，它通过基于通配符的模式匹配完成工作。\r\n\r\nHeaders exchange的允许在消息中自描述路由逻辑，在消息头的Basic.Properties中添加headers属性，headers表随意添加key/value对，队列与exchange的绑定使用的也不再是字符串数组，而是key/value对的数组，绑定会被设置一个叫x-match的参数，值为any或者all，any表示任意匹配，all则是全匹配。Headers exchange提供强大的路由机制，但代价是也给broker带来了额外的计算负担，在比较路由之前，headers表中的属性值会先被排序。但是有一点需要注意的是只要在消息的属性中设置了headers，那么无论消息被发送至什么类型的exchange上，性能都会受到影响。\r\n\r\n一个exchange可以有多个queue绑定，那么一个消息可以被发送至多个exchange吗？答案是可以的。通过exchange-to-exchange绑定，你可以做到这一切，不同于队列绑定使用Queue.Bind method，exchange绑定使用Exchange.Bind method。这种机制非常灵活，灵活可能会使系统变得复杂。rabbitmq中的主要exchange类型如下图所示：<div align=\"center\"><img src=\"../../resources/img/exchanges.png\"></div>"}]},{"tag":"中间件","payload":[{"title":"rabbitmq与AMQP","date":"2022-05-01","tags":["消息队列","中间件","rabbitmq"],"categories":"中间件","content":"\r\n\r\nrabbitmq是一款被广泛使用的消息队列中间件，它目前被Pivotal公司所拥有。其基于`AMQM`、`AMQP`并用`erlang`语言实现，拥有诸多特性，譬如开源、强大商业支持、跨语言、跨平台、轻量级、扩展性强、可定制、安全支持等。它可以通过分布式部署满足高可用的需求，其吞吐量亦十分可观，能够达到万/s的级别，当然吞吐量的高的代价是比较吃cpu，我们可以根据自身系统在可用性和性能两方面做权衡。另外rabbitmq还支持异地多活和异地多活多主架构。\r\nrabbitmq强悍的力量很大程度上是因为其基于`AMQP`，`AMQP`不仅定义了网络层协议而且对服务端的服务和行为也做了定义，即`AMQ model`。`AMQ model`就消息路由行为定义了三个抽象组件：`Exchange,Queue,Binding`。\r\n- Exchange：将消息路由给队列的组件\r\n- Queue：存在于内存或者磁盘中的存储消息的数据结构\r\n- Binding：Exchange将消息分发给Queue的规则\r\n\r\n将一个message发送到broker后，broker的行为如下图所示：<div align=\"center\"><img src=\"../../resources/img/rabbitmq-message-send.jpg\"></div>\r\n\r\n实际使用时，每种Exchange类型处理routing-key的行为会有所差异，有的不做任何处理，有些则需要进行复杂的模式匹配提取，header exchange甚至根本就不管routing-key是啥。rabbitmq在设计中扩展了AMQ model，exchange不仅接受queue的绑定，而且接受其他exchange的绑定，这种特性为消息的路由模式提供了相当的灵活性。\r\n\r\nrabbitmq客户端库的实现都会隐藏掉基于AMQP进行通信的复杂性，这或许对用户来说是一件好事，用户的绝大多数精力可以用在应用层上，不必关心实际上的复杂性。但我们还是应当熟悉AMQP协议，只有这样，我们才不会在应用性能没有达到预期或者是出现错误时束手无策。\r\n\r\nrabbitmq利用`RPC`模式实现AMQP的通信，但是具体实现又同一般的RPC模式有所不同。一般来说，进行RPC通信的双方，客户端发送指令给服务端，服务端处理后返回响应，这里服务端是不会发指令给客户端的，但是rabbitmq的RPC实现中，服务端会。<div align=\"center\"><img src=\"../../resources/img/rabbitmq-conversation.jpg\" height=600px></div>\r\n\r\nrabbitmq客户端与服务端之间建立通信首先需要经过三次握手。首先客户端会发送包含Protocol Header的Greeting给服务端，接着服务端发送Connection.Start给客户端，最后客户端发送Connection.StartOk给服务端，之后一个连接就建立了。在客户端与服务端之间进行有实际意义的交流之前，还得在连接中打开channel，在channel中进行AMQP帧的传输。channel是双工的，并且可以在一个连接中有多个，有点像HTTP2。\r\n\r\nAMQP的命令由类和方法组成，像Connection.Start中，Connection是对象，Start是方法。当命令被发送到客户端或者服务端时，执行命令所需的参数被封装到帧中进行传输。底层的AMQP帧大致上长这样。<div align=\"center\"><img src=\"../../resources/img/amqp-frame.jpg\" ></div>\r\n\r\n帧的头部由帧类型，channe编码，payload大小组成。有五种帧的类型如下所示：\r\n- protocol header frame：只会在在连接到rabbitmq时用到\r\n- method frame：携带RPC请求或者响应\r\n- content header frame：包含消息的大小和属性\r\n- body frame：消息内容\r\n- heartbeat frame：心跳检测确认通信双方存活\r\n\r\n在channel中的数据总是以`method frame`，`content header frame`，多个`body frame`的顺序流动。method frame被特殊编码以压缩大小，典型的method frame头两个字段包含类型和方法，之后的一个字段是exchange name，再然后是routing-key，最后可能会有一个mandatory字段以让rabbitmq在没有满足消息发布需求时给客户端进行反馈。content header frame的payload主体由Basic.Properties表组成，通过它可以很方便的实现消息的定制化。content header frame也会被特殊编码。body frame则不会被特殊编码，它可以装载各种格式的图片，json/xml格式数据或者是文档等。\r\n\r\n在AMQ model中，`exchange`和`queue`都是一等公民。创建一个exchange对应的method是Exchange.Declare,如果创建成功，rabbitmq会返回Exchange.DeclareOk,否则会返回Channel.Close。类似的，创建一个queue对应的method是Queue.Declare,如果创建成功，rabbitmq会返回Queue.DeclareOk,否则会返回Channel.Close。将一个queue绑定到exchange的method是Queue.Bind,绑定成功，rabbitmq会返回Queue.BindOk。以上的method在AMQP中都是同步命令，在AMQP中也有一些命令通过异步的方式来接受和发送消息。\r\n\r\n当我们通过Basic.Publish发布消息到rabbitmq中时，可以将消息存储到内存或者是磁盘中去，并且只会储存一份，丢到队列中的实际是实例的一份引用，不同队列的实例引用之间互不影响。当我们把消息丢到队列中去之后，剩下的就是消费了，客户端发送Basic.Consume请求消费，然后rabbitmq响应Basic.ConsumeOk表示可以开始消费，若客户端想要终止消费过程，可以发送Basic.Cancel,这是一个异步命令，所以客户端此时还是会收到rabbitmq发来的消息。\r\n\r\n受限于精力，能力和时间成本，rabbitmq的AMQP实现的了解暂时先到此为止。如果想进一步了解，可以参考[rabbitmq的官方文档](https://www.rabbitmq.com/protocol.html)。\r\n\r\n附上Basic.Properties的属性表：<div align=\"center\"><img src=\"../../resources/img/Basic-properties.png\"></div>\r\n"},{"title":"rabbitmq中的队列和exchange","date":"2022-05-02","tags":["rabbitmq","中间件","消息队列"],"categories":"中间件","content":"\r\n\r\n队列毫无疑问在消息队列中占据着核心地位，rabbitmq提供了诸多设置让我们能够自如地定义队列。这些设置有很多，挑一些常用的列举在下方：\r\n- 自动删除\r\n- 限制唯一消费者消费\r\n- 自动过期队列\r\n- 限制消息的数量\r\n\r\n非常重要的是，一旦我们创建了一个队列，队列的设置就无法被更改了，改变队列的设置只能通过删除然后重新创建的方式。\r\n\r\n通过在`Queue.Declare`请求中加入`auto_delete`标志可以创建临时队列，所谓临时队列就是一旦消费者拿走队列的全部消息、断开连接，队列就会被删除。值得留意的是，临时队列可以被任意数量的消费者消费，只有当不再有消费者监听该队列了，这个队列才会被删除。\r\n\r\n在队列声明请求中加入`exclusive`标志可以限制消费者的数量为一，声明一个排他队列，排他队列也会自动删除，但它的行为和临时队列有所不同，排他队列在连接断开后被删除，临时队列则与是否有订阅者有关。\r\n\r\n通过在队列声明请求中加入`x-expires`参数可以声明一个定时队列，参数单位为毫秒，定时队列会在过期时间到后被自动删除，需要注意的是只要定时队列上由消费者，那么除非消费者停止订阅或者连接断开，该队列是不会被自动删除的。另外当消费者向该队列发送`Basic.Get`请求后，`x-expires`参数就失效了，该队列不再是定时队列了。rabbitmq不保证删除定时队列的及时性。\r\n\r\n通过在创建队列请求中将`durable`参数置为true，可以让该队列成为一个永久队列，并被持久化到磁盘中去，直到`Queue.Delete`命令删除该队列。\r\n\r\n通过在创建队列时设置`x-message-ttl`可以设置队列中消息的过期时间，设置`x-max-length`可以设置队列最大消息数，当队列中的消息达到了这个数目，就无法向队列中添加消息了。如果该队列声明了`DLX`，那么过期的消息和无法添加的消息会被交给`DLX`处理。\r\n\r\n声明一个队列可使用的参数及其作用如下图所示：<div align=\"center\"><img src=\"../../resources/img/queue-argument.png\"></div>\r\n\r\nrabbitmq最强大的力量来自于exchange基于消息中的routing信息将消息路由至不同队列的灵活性。通过exchange，消息可以被路由至一个或多个队列，其他exchange，还可以是外部资源。在rabbitmq中有四种类型的exchange：\r\n- Direct exchange\r\n- Fanout exchange\r\n- Topic exchange\r\n- Headers exchange\r\n\r\nDirect exchange是rabbitmq中最简单的exchange，它可以被多个队列绑定，当消息发送至此exchange时，它会将消息的routing-key同与之绑定的队列的binding-key做比较，只有当两个字符串完全相等时，exchange才会将消息丢到队列中去。\r\n\r\nFanout exchange会将接受的消息发送到所有绑定的队列中去，因为不需要进行routing-key和binding-key的比较，所有性能会很好，但是也因为缺乏选择机制，路由至所有队列中的消息都应该被消费。\r\n\r\nTopic exchange同Direct exchange一样会基于routing-key选择性的路由消息到队列中，不同的是Topic exchange不需要完全匹配，它通过基于通配符的模式匹配完成工作。\r\n\r\nHeaders exchange的允许在消息中自描述路由逻辑，在消息头的Basic.Properties中添加headers属性，headers表随意添加key/value对，队列与exchange的绑定使用的也不再是字符串数组，而是key/value对的数组，绑定会被设置一个叫x-match的参数，值为any或者all，any表示任意匹配，all则是全匹配。Headers exchange提供强大的路由机制，但代价是也给broker带来了额外的计算负担，在比较路由之前，headers表中的属性值会先被排序。但是有一点需要注意的是只要在消息的属性中设置了headers，那么无论消息被发送至什么类型的exchange上，性能都会受到影响。\r\n\r\n一个exchange可以有多个queue绑定，那么一个消息可以被发送至多个exchange吗？答案是可以的。通过exchange-to-exchange绑定，你可以做到这一切，不同于队列绑定使用Queue.Bind method，exchange绑定使用Exchange.Bind method。这种机制非常灵活，灵活可能会使系统变得复杂。rabbitmq中的主要exchange类型如下图所示：<div align=\"center\"><img src=\"../../resources/img/exchanges.png\"></div>"}]},{"tag":"rabbitmq","payload":[{"title":"rabbitmq与AMQP","date":"2022-05-01","tags":["消息队列","中间件","rabbitmq"],"categories":"中间件","content":"\r\n\r\nrabbitmq是一款被广泛使用的消息队列中间件，它目前被Pivotal公司所拥有。其基于`AMQM`、`AMQP`并用`erlang`语言实现，拥有诸多特性，譬如开源、强大商业支持、跨语言、跨平台、轻量级、扩展性强、可定制、安全支持等。它可以通过分布式部署满足高可用的需求，其吞吐量亦十分可观，能够达到万/s的级别，当然吞吐量的高的代价是比较吃cpu，我们可以根据自身系统在可用性和性能两方面做权衡。另外rabbitmq还支持异地多活和异地多活多主架构。\r\nrabbitmq强悍的力量很大程度上是因为其基于`AMQP`，`AMQP`不仅定义了网络层协议而且对服务端的服务和行为也做了定义，即`AMQ model`。`AMQ model`就消息路由行为定义了三个抽象组件：`Exchange,Queue,Binding`。\r\n- Exchange：将消息路由给队列的组件\r\n- Queue：存在于内存或者磁盘中的存储消息的数据结构\r\n- Binding：Exchange将消息分发给Queue的规则\r\n\r\n将一个message发送到broker后，broker的行为如下图所示：<div align=\"center\"><img src=\"../../resources/img/rabbitmq-message-send.jpg\"></div>\r\n\r\n实际使用时，每种Exchange类型处理routing-key的行为会有所差异，有的不做任何处理，有些则需要进行复杂的模式匹配提取，header exchange甚至根本就不管routing-key是啥。rabbitmq在设计中扩展了AMQ model，exchange不仅接受queue的绑定，而且接受其他exchange的绑定，这种特性为消息的路由模式提供了相当的灵活性。\r\n\r\nrabbitmq客户端库的实现都会隐藏掉基于AMQP进行通信的复杂性，这或许对用户来说是一件好事，用户的绝大多数精力可以用在应用层上，不必关心实际上的复杂性。但我们还是应当熟悉AMQP协议，只有这样，我们才不会在应用性能没有达到预期或者是出现错误时束手无策。\r\n\r\nrabbitmq利用`RPC`模式实现AMQP的通信，但是具体实现又同一般的RPC模式有所不同。一般来说，进行RPC通信的双方，客户端发送指令给服务端，服务端处理后返回响应，这里服务端是不会发指令给客户端的，但是rabbitmq的RPC实现中，服务端会。<div align=\"center\"><img src=\"../../resources/img/rabbitmq-conversation.jpg\" height=600px></div>\r\n\r\nrabbitmq客户端与服务端之间建立通信首先需要经过三次握手。首先客户端会发送包含Protocol Header的Greeting给服务端，接着服务端发送Connection.Start给客户端，最后客户端发送Connection.StartOk给服务端，之后一个连接就建立了。在客户端与服务端之间进行有实际意义的交流之前，还得在连接中打开channel，在channel中进行AMQP帧的传输。channel是双工的，并且可以在一个连接中有多个，有点像HTTP2。\r\n\r\nAMQP的命令由类和方法组成，像Connection.Start中，Connection是对象，Start是方法。当命令被发送到客户端或者服务端时，执行命令所需的参数被封装到帧中进行传输。底层的AMQP帧大致上长这样。<div align=\"center\"><img src=\"../../resources/img/amqp-frame.jpg\" ></div>\r\n\r\n帧的头部由帧类型，channe编码，payload大小组成。有五种帧的类型如下所示：\r\n- protocol header frame：只会在在连接到rabbitmq时用到\r\n- method frame：携带RPC请求或者响应\r\n- content header frame：包含消息的大小和属性\r\n- body frame：消息内容\r\n- heartbeat frame：心跳检测确认通信双方存活\r\n\r\n在channel中的数据总是以`method frame`，`content header frame`，多个`body frame`的顺序流动。method frame被特殊编码以压缩大小，典型的method frame头两个字段包含类型和方法，之后的一个字段是exchange name，再然后是routing-key，最后可能会有一个mandatory字段以让rabbitmq在没有满足消息发布需求时给客户端进行反馈。content header frame的payload主体由Basic.Properties表组成，通过它可以很方便的实现消息的定制化。content header frame也会被特殊编码。body frame则不会被特殊编码，它可以装载各种格式的图片，json/xml格式数据或者是文档等。\r\n\r\n在AMQ model中，`exchange`和`queue`都是一等公民。创建一个exchange对应的method是Exchange.Declare,如果创建成功，rabbitmq会返回Exchange.DeclareOk,否则会返回Channel.Close。类似的，创建一个queue对应的method是Queue.Declare,如果创建成功，rabbitmq会返回Queue.DeclareOk,否则会返回Channel.Close。将一个queue绑定到exchange的method是Queue.Bind,绑定成功，rabbitmq会返回Queue.BindOk。以上的method在AMQP中都是同步命令，在AMQP中也有一些命令通过异步的方式来接受和发送消息。\r\n\r\n当我们通过Basic.Publish发布消息到rabbitmq中时，可以将消息存储到内存或者是磁盘中去，并且只会储存一份，丢到队列中的实际是实例的一份引用，不同队列的实例引用之间互不影响。当我们把消息丢到队列中去之后，剩下的就是消费了，客户端发送Basic.Consume请求消费，然后rabbitmq响应Basic.ConsumeOk表示可以开始消费，若客户端想要终止消费过程，可以发送Basic.Cancel,这是一个异步命令，所以客户端此时还是会收到rabbitmq发来的消息。\r\n\r\n受限于精力，能力和时间成本，rabbitmq的AMQP实现的了解暂时先到此为止。如果想进一步了解，可以参考[rabbitmq的官方文档](https://www.rabbitmq.com/protocol.html)。\r\n\r\n附上Basic.Properties的属性表：<div align=\"center\"><img src=\"../../resources/img/Basic-properties.png\"></div>\r\n"},{"title":"rabbitmq中的消息发布与消费","date":"2022-05-02","tags":["rabbitmq"],"categories":"中间件","content":"\r\n>多一分则肥，少一分则瘦\r\n\r\n消息中间件消息的发布需要在高性能与可靠性之间做权衡，rabbitmq依靠AMQP的事务规范，可选的持久化机制，以及自身的传输确认机制为我们构建不同等级的可靠系统提供了可能性。<div align=\"center\"><img src=\"../../resources/img/performance-with-guarantee.png\"></div>\r\n\r\nNotification on failure -- 当我们在Basic.Publish的method frame中添加mandatory标志时，如果消息没有被正确的路由，那么rabbitmq broker就会通过Basic.Return的RPC回传消息给publisher。在我们的代码中要注册回调函数处理这种路由失败的情况。Publisher confirms -- publisher发送Confirm.Select,rabbitmq broker回复Confirm.SelectOk，之后这条传递消息的channel就成了一个confirm channel，publisher每发送一条消息给服务器，如果消息都入队等待被消费并且被持久化到磁盘中，或者是消息在所有应该路由到的队列中都被消费者消费完毕了，服务端就会回复Basic.Ack，否则就会回复Basic.Nak。服务端异步回复confirm消息，在我们的代码中需要注册回调函数处理来自服务端的回复。Alternate exchanges -- 当我们声明一个exchange，可以给它绑定一个备用exchange，当发送给给此exchange的消息无法被路由时，此备选exchange就会接管工作，将消息路由到死信队列中去，值得注意的是，一旦同时设置mandatory标志和备选队列，那么mandatory就失效了。Transactions -- AMQP规范中定义了事务来保证批处理的原子性。publisher发送TX.Select,服务端回传TX.SelectOk，事务就开始了，可以在事务中发送一条或者多条消息，消息发送完毕publisher发送TX.Commit，然后在收到服务端的TX.CommitOk后，事务就完成了。这里需要注意的是当事务执行过程中，发生错误了，那么服务端就会发送Basic.Return,publisher如果想终止事务，可以发送TX.Rollback，然后等待服务端回传TX.RollbackOk。另外，rabbitmq在实现AMQP事务规范时只有当命令只影响一条队列时，才保证其原子性，当有多条队列收到影响时，原子性就会被打破。事务机制比较影响性能。HA queues -- HA queue需要在集群环境中使用，在定义队列时，将队列声明为高可用队列，模式若设为all，则集群中的所有结点都会同步此队列的状态。若模式为nodes，则可自定义同步节点。一旦消费者在任意节点消费了此队列中的消息，所有节点中的该条消息就会立刻被删除。HA queues拥有一个主节点，其他的都是副节点，如果主节点挂了，其他的某个副节点就会成为新的主节点。如果挂了的节点恢复了，或者集群中加入了新的节点，那么它们会接受新发送来的消息，并且在队列中的旧消息都消费完毕了才会加入同步集。HA queues with transactions -- 这种方式会引入相当的响应延迟，慎重使用。Persisted messages -- 持久化选项由Basic.Properties中的delivery-mode控制，默认为1，表示不持久化，如果想要持久化，则应该设为2，另外装此消息的队列也应该被设置为持久化队列。\r\n\r\n上面一段讲了向rabbitmq发布消息的问题，这一段我们看看怎么从rabbitmq获取消息。有两种方法可以从rabbitmq获取消息，`Basic.Get` & `Basic.Consume`。Basic.Get使用一种拉的模式从broker中获取消息，consumer想要获取一个消息都必须发送一个新的Basic.Get RPC请求，broker会根据queue中是否有代办消息回复`Basic.GetOk` or `Basic.GetEmpty`，消费端需要根据回复进行相应的处理。Basic.Get的这种同步方式对性能有明显的影响，更重要的是，由于consume是消费端主动发起的，所以broker也无法优化整个传输过程。与`Basic.Get`相反的是，`Basic.Consume`以一种推的方式从broker中获取消息，发送Basic.Consume RPC请求到broker后，rabbitmq就会在broker中注册你的应用，然后直到你发送`Basic.Cancel`之前,broker都以一种异步的方式将队列中的消息发送给消费者。当然从broker获取到消息之后，消费端也需要向broker发送`Basic.Ack`让它知道消息已经被正常消费了。同publish一样，消费消息也需要在吞吐量和可靠性之间做权衡。<div align=\"center\"><img src=\"../../resources/img/consume-with-guarantee.png\"></div>\r\n\r\nno-ack -- 当向rabbitmq发送Basic.Consume注册我们的应用进行消费时，在请求中携带no-ack的标志时，broker就会知道消费端不会ack，应该尽可能快速地将消息发送给消费端。Consuming with acknowledgement and Qos > 1 -- 通过向broker发送Basic.Qos请求，我们可以设置一条channel的服务质量，broker会在这条channel上连续发送预设数量的message后，等待消费端的回复，消费端可以选择依旧每条消息都回复，也可以通过在Basic.Ack中设置multiple标志而不必每条消息都回复，broker会将没有收到回复的消息写回到队列中。当然设置multiple标志的方式会有重复消费的风险。transaction -- 事务方式可以规避重复消费的风险，代价是吞吐量不及QoS的方式。\r\n\r\n当消费端在接收消息或者处理消息的过程中发生异常情况时，rabbitmq提供两种方式将消息踢还给broker：`Basic.Reject` & `Basic.Nak`。发送Basic.Reject给服务端时，若在请求中携带requeue标志，则broker会将消息重新入队，否则broker只是简单的将消息丢弃。Basic.Nak的行为与Basic.Reject类似，不同的是其类似Basic.Ack可以在一次回复中携带多个拒绝信息，它也不是AMQP原生支持的命令。除了这两条命令，rabbitmq还提供叫做死信exchange(DLX)的扩展，DLX同队列进行绑定，一个队列中被拒绝且没有重新入队的消息或者过期的消息会被交给DLX。"},{"title":"rabbitmq中的队列和exchange","date":"2022-05-02","tags":["rabbitmq","中间件","消息队列"],"categories":"中间件","content":"\r\n\r\n队列毫无疑问在消息队列中占据着核心地位，rabbitmq提供了诸多设置让我们能够自如地定义队列。这些设置有很多，挑一些常用的列举在下方：\r\n- 自动删除\r\n- 限制唯一消费者消费\r\n- 自动过期队列\r\n- 限制消息的数量\r\n\r\n非常重要的是，一旦我们创建了一个队列，队列的设置就无法被更改了，改变队列的设置只能通过删除然后重新创建的方式。\r\n\r\n通过在`Queue.Declare`请求中加入`auto_delete`标志可以创建临时队列，所谓临时队列就是一旦消费者拿走队列的全部消息、断开连接，队列就会被删除。值得留意的是，临时队列可以被任意数量的消费者消费，只有当不再有消费者监听该队列了，这个队列才会被删除。\r\n\r\n在队列声明请求中加入`exclusive`标志可以限制消费者的数量为一，声明一个排他队列，排他队列也会自动删除，但它的行为和临时队列有所不同，排他队列在连接断开后被删除，临时队列则与是否有订阅者有关。\r\n\r\n通过在队列声明请求中加入`x-expires`参数可以声明一个定时队列，参数单位为毫秒，定时队列会在过期时间到后被自动删除，需要注意的是只要定时队列上由消费者，那么除非消费者停止订阅或者连接断开，该队列是不会被自动删除的。另外当消费者向该队列发送`Basic.Get`请求后，`x-expires`参数就失效了，该队列不再是定时队列了。rabbitmq不保证删除定时队列的及时性。\r\n\r\n通过在创建队列请求中将`durable`参数置为true，可以让该队列成为一个永久队列，并被持久化到磁盘中去，直到`Queue.Delete`命令删除该队列。\r\n\r\n通过在创建队列时设置`x-message-ttl`可以设置队列中消息的过期时间，设置`x-max-length`可以设置队列最大消息数，当队列中的消息达到了这个数目，就无法向队列中添加消息了。如果该队列声明了`DLX`，那么过期的消息和无法添加的消息会被交给`DLX`处理。\r\n\r\n声明一个队列可使用的参数及其作用如下图所示：<div align=\"center\"><img src=\"../../resources/img/queue-argument.png\"></div>\r\n\r\nrabbitmq最强大的力量来自于exchange基于消息中的routing信息将消息路由至不同队列的灵活性。通过exchange，消息可以被路由至一个或多个队列，其他exchange，还可以是外部资源。在rabbitmq中有四种类型的exchange：\r\n- Direct exchange\r\n- Fanout exchange\r\n- Topic exchange\r\n- Headers exchange\r\n\r\nDirect exchange是rabbitmq中最简单的exchange，它可以被多个队列绑定，当消息发送至此exchange时，它会将消息的routing-key同与之绑定的队列的binding-key做比较，只有当两个字符串完全相等时，exchange才会将消息丢到队列中去。\r\n\r\nFanout exchange会将接受的消息发送到所有绑定的队列中去，因为不需要进行routing-key和binding-key的比较，所有性能会很好，但是也因为缺乏选择机制，路由至所有队列中的消息都应该被消费。\r\n\r\nTopic exchange同Direct exchange一样会基于routing-key选择性的路由消息到队列中，不同的是Topic exchange不需要完全匹配，它通过基于通配符的模式匹配完成工作。\r\n\r\nHeaders exchange的允许在消息中自描述路由逻辑，在消息头的Basic.Properties中添加headers属性，headers表随意添加key/value对，队列与exchange的绑定使用的也不再是字符串数组，而是key/value对的数组，绑定会被设置一个叫x-match的参数，值为any或者all，any表示任意匹配，all则是全匹配。Headers exchange提供强大的路由机制，但代价是也给broker带来了额外的计算负担，在比较路由之前，headers表中的属性值会先被排序。但是有一点需要注意的是只要在消息的属性中设置了headers，那么无论消息被发送至什么类型的exchange上，性能都会受到影响。\r\n\r\n一个exchange可以有多个queue绑定，那么一个消息可以被发送至多个exchange吗？答案是可以的。通过exchange-to-exchange绑定，你可以做到这一切，不同于队列绑定使用Queue.Bind method，exchange绑定使用Exchange.Bind method。这种机制非常灵活，灵活可能会使系统变得复杂。rabbitmq中的主要exchange类型如下图所示：<div align=\"center\"><img src=\"../../resources/img/exchanges.png\"></div>"}]}];
